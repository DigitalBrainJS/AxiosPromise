{"version":3,"file":"axios-promise.min.js","sources":["../../lib/utils.js","../../lib/CanceledError.js","../../lib/TimeoutError.js","../../lib/EventEmitter.js","../../lib/AbortController.js","../../lib/index.js","../../lib/env/data.js"],"sourcesContent":["const {\n  hasOwn = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype)\n} = Object;\n\nconst isFunction = (thing) => typeof thing === 'function';\n\nconst _global = typeof globalThis === 'object' && globalThis ||\n  (typeof global !== \"undefined\" && global) ||\n  (typeof self !== \"undefined\" && self) || window\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios-promise@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\nconst functionTypeTest = ({constructor}) => {\n  const {name} = constructor;\n  return (thing) => thing && isFunction(thing) && (thing.constructor === constructor || (name && thing.constructor.name === name));\n}\n\nconst isGeneratorFunction = functionTypeTest(function* () {});\n\nconst isAsyncFunction = functionTypeTest(async () => {});\n\nconst isPlainFunction = functionTypeTest(() => {});\n\nconst isGenerator = (obj) => obj && isFunction(obj.next) && isFunction(obj.throw);\n\nconst isContextDefined = (context) => context != null && context !== _global;\n\nconst lazyBind = (obj, props, {bindMethods = true} = {}) => {\n  const symbols = {};\n\n  props.forEach(prop => {\n    const symbol = Symbol(`${prop}Lazy`);\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    const {value, get, enumerable} = descriptor;\n\n    if('value' in descriptor && !isFunction(value)) {\n      console.warn('skip', prop);\n      return;\n    }\n\n    Object.defineProperty(obj, prop, {\n      get() {\n        if (hasOwn.call(this, symbol)) {\n          return this[symbol];\n        }\n\n        const resolvedValue = get ? get.call(this) : value;\n\n        const boundContext = this;\n\n        return this[symbol] = bindMethods && isFunction(resolvedValue) ? function () {\n          return resolvedValue.apply(isContextDefined(this) ? this : boundContext, arguments);\n        } : resolvedValue;\n      },\n\n      set(v) {\n        throw Error(`Can not rewrite prop ${prop} with ${v}`);\n      },\n\n      enumerable,\n      configurable: true\n    });\n\n    symbols[prop] = symbol;\n  });\n\n  return symbols;\n}\n\nconst defineConstants = (obj, props, {configurable = true, enumerable = true} = {}) => {\n  const descriptors = {};\n\n  Object.getOwnPropertyNames(props).forEach((prop) => {\n    descriptors[prop] = {value: props[prop], enumerable, configurable}\n  })\n\n  Object.defineProperties(obj, descriptors);\n};\n\nconst isAbortSignal = (thing) => {\n  return thing &&\n    typeof thing === 'object' &&\n    typeof thing.aborted === 'boolean' &&\n    isFunction(thing.addEventListener) &&\n    isFunction(thing.removeEventListener);\n}\n\nconst isAbortController = (thing) => {\n  return thing && typeof thing === 'object' && isFunction(thing.abort) && isAbortSignal(thing.signal);\n};\n\nconst symbols = (...tags) => ({\n  * [Symbol.iterator]() {\n    while (true) {\n      yield Symbol(tags.shift() || '');\n    }\n  }\n})\n\nexport default {\n  global: _global,\n  setImmediate: _setImmediate,\n  asap,\n  isGeneratorFunction,\n  isFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  functionTypeTest,\n  isContextDefined,\n  hasOwn,\n  lazyBind,\n  isGenerator,\n  defineConstants,\n  isAbortSignal,\n  isAbortController,\n  symbols\n}\n","const kInternals = Symbol('internals');\nconst kSignature = Symbol.for(`AxiosPromise.CanceledError`);\n\nexport class CanceledError extends Error {\n  constructor(message) {\n    super(message || 'canceled');\n    const {name, code} = this.constructor[kInternals];\n    this.name = name;\n    this.code = code;\n  }\n\n  static from(thing) {\n    return this.isCanceledError(thing) ? thing : new this(thing instanceof Error ? thing.message : '');\n  }\n\n  static isCanceledError(err) {\n    return !!(err && err[kSignature]);\n  }\n\n  static addSignature(constructor) {\n    typeof constructor === 'function' && (constructor.prototype[kSignature] = this[kInternals].code);\n  }\n\n  static rethrow(err, code) {\n    if (this.isCanceledError(err) && (!code || code === err.code)) {\n      throw err;\n    }\n  }\n\n  static init(name, code) {\n    this[kInternals] = {\n      name,\n      code: code || 'ERR_' + name.toUpperCase().replace(/ERROR$/, '')\n    }\n\n    this.addSignature(this);\n  }\n}\n\nCanceledError.init('CanceledError');\n","import {CanceledError} from './CanceledError.js';\n\nexport class TimeoutError extends CanceledError {\n  constructor(messageOrTimeout) {\n    super(typeof messageOrTimeout === 'number' ? `${messageOrTimeout} ms timeout exceeded` : messageOrTimeout);\n  }\n}\n\nTimeoutError.init('TimeoutError');\n\n","export default class EventEmitter {\n  constructor(events) {\n    this._events = events || {};\n  }\n\n  on(event, listener, prepend) {\n    const events = this._events\n    const listeners = events[event];\n\n    events['newListener'] && this.emit('newListener', event, listener);\n\n    if (!listeners) {\n      events[event] = listener\n    } else if (typeof listeners === 'function') {\n      events[event] = prepend ? [listener, listeners] : [listeners, listener];\n    } else {\n      prepend ? listener.unshift(listener) : listeners.push(listener);\n    }\n\n    return this;\n  }\n\n  off(event, listener) {\n    const events = this._events\n    const listeners = events[event];\n    let found = false;\n\n    if (listeners) {\n      if (typeof listeners === 'function') {\n        if (listeners === listener) {\n          events[event] = null;\n          found = true;\n        }\n      } else {\n        let i = listeners.length;\n        while (i--) {\n          if (listeners[i] === listener) {\n            listeners.splice(i, 1);\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    found && events['removeListener'] && this.emit('removeListener', event, listener);\n\n    return found;\n  }\n\n  emit(event) {\n    const listeners = this._events[event];\n    if (!listeners) return false;\n\n    const args = Array.from(arguments).slice(1);\n\n    if (typeof listeners === 'function') {\n      listeners.apply(null, args);\n    } else {\n      const l = listeners.length;\n      for (let i = 0; i < l; i++) {\n        listeners.apply(null, args);\n      }\n    }\n    return true;\n  }\n\n  once(event, listener, prepend) {\n    const once = () => {\n      this.off(event, once);\n      listener.apply(null, arguments);\n    };\n\n    return this.on(event, once, prepend);\n  }\n\n  listenerCount(event) {\n    const listeners = this._events[event];\n    return listeners ? (typeof listeners === 'function' ? 1 : listeners.length) : 0;\n  }\n}\n\nconst {prototype} = EventEmitter;\n\nprototype.addEventListener = prototype.on;\nprototype.removeEventListener = prototype.off;\n","import utils from './utils.js';\nimport EventEmitter from \"./EventEmitter.js\";\n\nconst [kSignal, kAborted, kAbort] = utils.symbols('signal', 'aborted', 'abort');\n\nconst hasNativeSupport = typeof AbortController === 'function' && typeof AbortSignal === 'function';\n\nconst _AbortSignal = hasNativeSupport ? AbortSignal : class AbortSignal extends EventEmitter{\n  constructor() {\n    super();\n    this[kAborted] = false;\n  }\n\n  get aborted() {\n    return this[kAborted];\n  }\n\n  [kAbort]() {\n    if (!this[kAborted]) {\n      this[kAborted] = true;\n      this.dispatchEvent('abort');\n    }\n  }\n\n  dispatchEvent(type) {\n    const event = {\n      type,\n      target: this\n    };\n\n    let listener;\n\n    typeof (listener = this['on' + type]) === 'function' && listener.call(this, event);\n\n    this.emit(type, event)\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AbortSignal'\n  }\n\n  toString() {\n    return '[object AbortSignal]'\n  }\n}\n\nconst _AbortController = hasNativeSupport ? AbortController : class AbortControllerPolyfill {\n  constructor() {\n    this[kSignal] = null;\n  }\n\n  get signal() {\n    return this[kSignal] || (this[kSignal] = new _AbortSignal());\n  }\n\n  abort(reason) {\n    this.signal[kAbort](reason);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AbortController'\n  }\n\n  toString() {\n    return '[object AbortController]'\n  }\n}\n\nexport {\n  _AbortController as AbortController,\n  _AbortSignal as AbortSignal,\n}\n","import utils from './utils.js';\nimport {CanceledError} from \"./CanceledError.js\";\nimport {TimeoutError} from \"./TimeoutError.js\";\nimport {AbortController, AbortSignal} from \"./AbortController.js\"\nimport EventEmitter from \"./EventEmitter.js\";\nimport {VERSION} from \"./env/data.js\";\n\nconst {\n  isGenerator,\n  isFunction,\n  isGeneratorFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  isContextDefined,\n  lazyBind,\n  defineConstants,\n  symbols,\n  isAbortSignal,\n  global,\n  setImmediate,\n  isAbortController,\n  asap\n} = utils;\n\nconst kPromiseSign = Symbol.for('AxiosPromise');\n\nconst [\n  kState,\n  kValue,\n  kCallbacks,\n  kDoResolve,\n  kResolveTo,\n  kResolve,\n  kParent,\n  kInnerThenable,\n  kCanceled,\n  kFinalized,\n  kSync,\n  kCallback,\n  kCancelCallbacks,\n  kInternals,\n  kFinalize,\n  kUnsubscribe,\n  kResolveGenerator,\n  kAtomic,\n  kCanceledWith,\n  kUncaught,\n  kTag,\n  kTimer\n] = symbols(\n  'state',\n  'value',\n  'callbacks',\n  'doResolve',\n  'resolveTo',\n  'resolve',\n  'parent',\n  'innerThenable',\n  'canceled',\n  'finalized',\n  'sync',\n  'callback',\n  'cancelCallbacks',\n  'internals',\n  'finalize',\n  'unsubscribe',\n  'resolveGenerator',\n  'atomic',\n  'canceledWith',\n  'uncaught',\n  'tag',\n  'timer'\n);\n\nconst STATE_PENDING = 0;\nconst STATE_FULFILLED = 1;\nconst STATE_REJECTED = 2;\n\nconst ATOMIC_MODE_AWAIT = false;\nconst ATOMIC_MODE_DETACHED = true;\n\nconst {push} = Array.prototype;\n\nconst hasConsole = typeof console !== 'undefined' && console;\n\nconst noop = () => {};\n\nconst getMethod = (obj, name) => {\n  let type;\n  let then;\n\n  if(((type = typeof obj) === 'object' || type === 'function') && typeof (then = obj[name]) === 'function') {\n    return then;\n  }\n}\n\nconst invokeCallbacks = (callbacks, args, that) => {\n  if(!callbacks) return false;\n\n  if (typeof callbacks === 'function') {\n    callbacks.apply(that, args);\n    return true;\n  } else {\n    const {length} = callbacks;\n    for (let i = 0; i < length; i++) {\n      callbacks[i].apply(that, args);\n    }\n    return !!length;\n  }\n}\n\nexport class AxiosPromise{\n  constructor(executor, {signal, timeout} = {}) {\n    this[kState] = STATE_PENDING;\n    this[kCallbacks] = null;\n    this[kInternals] = {\n      signals: null\n    }\n\n    if(signal) {\n      if(signal.aborted) {\n        this.cancel();\n        return this;\n      }\n\n      this.listen(signal);\n    }\n\n    timeout && this.timeout(timeout);\n\n    let type;\n\n    if(executor !== noop) {\n      if ((type = typeof executor) !== 'function') {\n        this[kResolveTo](new TypeError(`Promise resolver ${type} is not a function`));\n        return this;\n      }\n\n      const maybeOnCancelSubscriber = this[kDoResolve](executor);\n\n      if (maybeOnCancelSubscriber && isFunction(maybeOnCancelSubscriber)) {\n        this.onCancel(maybeOnCancelSubscriber);\n      }\n    }\n  }\n\n  [kDoResolve](fn, fnContext) {\n    let done = false;\n\n    try {\n      return fn.call(fnContext,\n        (value) => {\n          if (done) return;\n          done = true;\n          this[kResolve](value, false);\n        }, (reason) => {\n          if (done) return;\n          done = true;\n          this[kResolveTo](reason, true);\n        }, this);\n    } catch (e) {\n      if (done) return;\n      done = true;\n      this[kResolveTo](e, true);\n    }\n  }\n\n  timeout(ms) {\n    if (!this[kState]) {\n      if (this[kTimer]) {\n        clearTimeout(this[kTimer]);\n        this[kTimer] = 0;\n      }\n\n      if (ms > 0) {\n        this[kTimer] = setTimeout(() => {\n          this[kTimer] = 0;\n          this.cancel(new TimeoutError(ms))\n        }, ms);\n      }\n    }\n    return this;\n  }\n\n  tag(tag) {\n    if (!arguments.length) {\n      return this[kTag] || '';\n    }\n    this[kTag] = String(tag);\n    return this;\n  }\n\n  atomic(mode = ATOMIC_MODE_AWAIT) {\n    const promise = this.then();\n\n    promise[kAtomic] = (this[kAtomic] = !!mode);\n\n    return promise;\n  }\n\n  static atomic(chain, mode = ATOMIC_MODE_AWAIT) {\n    return this.resolve(chain, {atomic: mode})\n  }\n\n  uncaught(handler = noop) {\n    const appendedHandler = this[kUncaught];\n    this[kUncaught] = appendedHandler && appendedHandler !== noop ? [appendedHandler, handler] : handler;\n    return this;\n  }\n\n  cancel(reason, forced) {\n    if (this[kFinalized]) return false;\n\n    let target = this;\n    let parent;\n    let atomic = target[kAtomic];\n\n    while (atomic === undefined && (parent = target[kParent]) && !parent[kFinalized] && (forced || typeof parent[kCallbacks] === 'function' || parent[kCallbacks].length <= 1)) {\n      atomic = parent[kAtomic]\n      target = parent;\n    }\n\n    reason = CanceledError.from(reason);\n\n    if (atomic === ATOMIC_MODE_AWAIT) {\n      target[kCanceledWith] = reason;\n      return true;\n    }\n\n    const innerThenable = target[kInnerThenable];\n\n    if (!(innerThenable && typeof innerThenable.cancel === 'function' && innerThenable.cancel(reason)) && !target[kCanceled]) {\n      reason.scope = target;\n      target[kResolveTo](reason, true);\n    }\n\n    return true;\n  }\n\n  listen(signal) {\n    if (!isAbortSignal(signal)) {\n      throw TypeError('expected AbortSignal object');\n    }\n\n    const internals = this[kInternals];\n\n    if (internals.signals) {\n      internals.signals.push(signal);\n    } else {\n      internals.signals = [signal];\n    }\n\n    signal.addEventListener('abort', () => this.cancel());\n\n    return this;\n  }\n\n  onCancel(listener) {\n    this[kCancelCallbacks] ? this[kCancelCallbacks].push(listener) : this[kCancelCallbacks] = [listener];\n  }\n\n  get signal(){\n    return (this[kInternals].controller = new AbortController()).signal;\n  }\n\n  [kUnsubscribe](chain) {\n    const parentCallbacks = this[kCallbacks];\n    const callback = chain[kCallback];\n    if(typeof parentCallbacks === 'function' && parentCallbacks === callback) {\n      this[kCallbacks] = null;\n    } else {\n      let i = parentCallbacks.length;\n      while (i--) {\n        if (parentCallbacks[i] === callback) {\n          return parentCallbacks.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  [kFinalize](){\n    this[kFinalized] = true;\n\n    let value = this[kValue];\n    let isRejected = this[kState] === STATE_REJECTED;\n    let canceled = this[kCanceled];\n    const internals = this[kInternals];\n    const {signals, controller} = internals;\n    const parent = this[kParent];\n\n    if (!isRejected && this[kCanceledWith]) {\n      canceled = true;\n      isRejected = true;\n      value = this[kCanceledWith];\n    }\n\n    if (parent && !parent[kFinalized]) { // Premature resolving - unsubscribe from parent chain\n      parent[kUnsubscribe](this);\n    }\n\n    this[kTimer] && clearTimeout(this[kTimer]);\n\n    if (signals) {\n      let i = signals.length;\n      while (i--) {\n        signals[i].removeEventListener('abort', this.cancel);\n      }\n    }\n\n    if(canceled){\n      const cancelCallbacks = this[kCancelCallbacks];\n\n      if (cancelCallbacks) {\n        invokeCallbacks(cancelCallbacks, [value]);\n      }\n\n      controller && controller.abort();\n    }\n\n    const callbacks = this[kCallbacks];\n\n    let hasCallback;\n\n    if(callbacks) {\n      if (typeof callbacks === 'function') {\n        hasCallback = true;\n        callbacks(value, isRejected);\n      } else {\n        const {length} = callbacks;\n        hasCallback = length;\n        for (let i = 0; i < length; i++) {\n          callbacks[i](value, isRejected);\n        }\n      }\n    }\n\n    if(isRejected && !hasCallback && !canceled) {\n      const uncaughtCallbacks = this[kUncaught];\n      if (uncaughtCallbacks) {\n        uncaughtCallbacks !== noop && invokeCallbacks(uncaughtCallbacks, [value])\n      } else if (hasConsole && this[kAtomic] !== ATOMIC_MODE_DETACHED) {\n        this.constructor._unhandledRejection(value);\n      }\n    }\n\n    this[kCallbacks] = null;\n    this[kParent] = null;\n    this[kCancelCallbacks] = null;\n    this[kInnerThenable] = null;\n    this[kInternals] = null;\n    this[kUncaught] = null;\n    this[kTimer] = null;\n  }\n\n  [kResolveTo](value, isRejected) {\n    if (this[kFinalized]) return;\n\n    const settled = this[kState];\n\n    if (isRejected && CanceledError.isCanceledError(value)) {\n      this[kCanceled] = true;\n    } else if (settled) {\n      return;\n    }\n\n    this[kValue] = value;\n\n    if (!settled) {\n      this[kState] = isRejected ? STATE_REJECTED : STATE_FULFILLED;\n\n      this[kSync] ? this[kFinalize]() : asap(() => this[kFinalize]());\n    }\n  }\n\n  [kResolve](value, isRejected) {\n    const {constructor} = this;\n    let then;\n\n    if (this === value) {\n      return this[kResolveTo](new TypeError(`circular reference to ${value}`), true);\n    }\n\n    if (value && isGenerator(value)) {\n      then = (value = constructor[kResolveGenerator](value, new constructor(noop))).then;\n    } else if (value) {\n      try {\n        then = getMethod(value, 'then');\n      } catch (err) {\n        return this[kResolveTo](err, true);\n      }\n    }\n\n    if (then && typeof then === 'function') {\n      this[kInnerThenable] = value;\n      this[kDoResolve](then, value);\n    } else {\n      this[kResolveTo](value, isRejected)\n    }\n\n  }\n\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    onRejected = typeof onRejected === 'function' ? onRejected : null;\n\n    return new this.constructor(($, $$, promise) => {\n      let invoked;\n\n      const resolver = (value, isRejected) => {\n        if (invoked) return;\n\n        invoked = true;\n\n        const handler = isRejected ? onRejected : onFulfilled;\n\n        try {\n          promise[kResolve](handler ? handler(value, promise) : value, isRejected && !handler);\n        } catch (err) {\n          promise[kResolveTo](err, true);\n        }\n      };\n\n      promise[kParent] = this;\n\n      if (this[kFinalized]) {\n        return this[kSync] ?\n          resolver(this[kValue], this[kState] === STATE_REJECTED) :\n          asap(() => {\n            resolver(this[kValue], this[kState] === STATE_REJECTED)\n          });\n      }\n\n      promise[kCallback] = resolver;\n\n      const callbacks = this[kCallbacks];\n\n      if (callbacks) {\n        typeof callbacks === 'function' ? this[kCallbacks] = [callbacks, resolver] : callbacks.push(resolver);\n      } else {\n        this[kCallbacks] = resolver;\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  finally(callback) {\n    let {constructor} = this;\n\n    return isFunction(callback) ? this.then(\n      (value, scope) => constructor.resolve(callback({value, status: 'fulfilled'}, scope)).then(() => value),\n      (reason, scope) => constructor.resolve(callback({reason, status: 'rejected'}, scope)).then(() => {\n        throw reason;\n      })) : this.then(callback, callback);\n  }\n\n  static allSettled(promises) {\n    return this.all(Array.from(promises).map(promise => promise.then(value => ({\n        status: 'fulfilled', value\n      }), (reason) => ({\n        status: 'rejected', reason\n      }))\n    ))\n  }\n\n  get [Symbol.toStringTag](){\n    return 'AxiosPromise';\n  }\n\n  toString() {\n    const tag = this[kTag];\n    return `${this[Symbol.toStringTag]}${tag ? '#' + tag : ''}{${['pending', 'fulfilled', 'rejected'][this[kState]]}}`\n  }\n\n  static resolve(value, options) {\n    const atomic = options != null ? !!options.atomic : undefined;\n\n    if (value instanceof this && value[kSync] === this[kSync] && value[kAtomic] === atomic) {\n      return value;\n    }\n    const promise = new this(resolve => resolve(value));\n\n    atomic && (promise[kAtomic] = atomic);\n\n    return promise;\n  }\n\n  static reject(reason) {\n    return new this((_, reject) => reject(reason));\n  }\n\n  static all(promises) {\n    return new this((resolve, reject, {onCancel}) => {\n      const {length} = promises = Array.from(promises);\n\n      if (!length) {\n        resolve([]);\n        return;\n      }\n\n      const chains = new Array(length);\n      const results = new Array(length);\n      let cancelRequested;\n      let subscribed;\n      let canceled;\n      let counter = 0;\n\n      const cancel = (reason) => {\n        if (subscribed) {\n          canceled = true;\n          for (let i = 0; i < length; i++) {\n            chains[i].cancel(reason)\n          }\n        } else {\n          cancelRequested = true;\n        }\n      }\n\n      const _reject = (reason) => {\n        reject(reason);\n        !canceled && cancel();\n      };\n\n      for (let i = 0; i < length; i++) {\n        chains[i] = this.resolve(promises[i]).then((value) => {\n          results[i] = value;\n          if (++counter === length) {\n            resolve(value);\n          }\n        }, _reject);\n      }\n\n      subscribed = true;\n\n      cancelRequested ? cancel() : onCancel(cancel);\n    })\n  }\n\n  static race(promises) {\n    return new this((resolve, reject, {onCancel}) => {\n      const {length} = promises = Array.from(promises);\n\n      if (!length) {\n        return;\n      }\n\n      const chains = new Array(length);\n      let cancelRequested;\n      let subscribed;\n      let canceled;\n\n      const cancel = (reason) => {\n        if (subscribed) {\n          canceled = true;\n          for (let i = 0; i < length; i++) {\n            chains[i].cancel(reason)\n          }\n        } else {\n          cancelRequested = true;\n        }\n      }\n\n      const _reject = (reason) => {\n        try {\n          reject(reason);\n        } finally {\n          !canceled && cancel();\n        }\n      };\n\n      for (let i = 0; i < length; i++) {\n        chains[i] = this.resolve(promises[i]).then((value) => {\n          resolve(value);\n          !canceled && cancel();\n        }, _reject);\n      }\n\n      subscribed = true;\n\n      cancelRequested ? cancel() : onCancel(cancel);\n    })\n  }\n\n  static delay(ms, value) {\n    return new this((resolve, _, {onCancel})=> {\n      const timer = setTimeout(resolve, ms, value);\n      onCancel(()=> clearTimeout(timer));\n    });\n  }\n\n  static isCanceledError(thing) {\n    return CanceledError.isCanceledError(thing);\n  }\n\n  static isAxiosPromise(thing) {\n    return !!(thing && thing[kPromiseSign]);\n  }\n\n  static [kResolveGenerator](generator, promise) {\n    const onFulfilled = (result) => {\n      try {\n        next(generator.next(result));\n      } catch (e) {\n        promise[kResolveTo](e, true)\n      }\n    }\n\n    const onRejected = (err) => {\n      try {\n        next(generator.throw(err));\n      } catch (e) {\n        promise[kResolveTo](e, true);\n      }\n    }\n\n    const next = (r) => {\n      if (r.done) {\n        return promise[kResolve](r.value);\n      }\n\n      const innerPromise = this.resolve(r.value).then(onFulfilled, onRejected);\n\n      promise[kInnerThenable] = innerPromise;\n\n      return innerPromise;\n    }\n\n    onFulfilled();\n\n    return promise;\n  }\n\n  static _unhandledRejection(reason) {\n    const source = this[kTag] ? ` @ ${this[kTag]}` : '';\n    console.warn(`Unhandled AxiosPromise Rejection${source}:`, reason);\n  }\n\n  static promisify(fn, {scopeArg = false} = {}) {\n    if (!isGeneratorFunction(fn)) {\n      throw new TypeError(`value must be a generator function`);\n    }\n\n    const context = this;\n\n    return function () {\n      return new context((resolve, reject, scope) => {\n        let generatorArgs;\n        if (scopeArg) {\n          generatorArgs = [scope];\n          push.apply(generatorArgs, arguments);\n        } else {\n          generatorArgs = arguments;\n        }\n\n        context[kResolveGenerator](fn.apply(this, generatorArgs), scope)\n      });\n    }\n  }\n}\n\nconst {prototype} = AxiosPromise;\n\nprototype[kSync] = false;\n\nlazyBind(prototype, ['cancel', 'onCancel', 'signal']);\nlazyBind(AxiosPromise,['delay', 'promisify']);\n\ndefineConstants(AxiosPromise, {\n  VERSION,\n  AbortController,\n  AbortSignal,\n  CanceledError,\n  TimeoutError,\n});\n\nexport class AxiosPromiseSync extends AxiosPromise {\n  get [Symbol.toStringTag](){\n    return 'AxiosPromiseSync';\n  }\n}\n\nAxiosPromiseSync.prototype[kSync] = true;\n\nexport {\n  isGenerator,\n  isGeneratorFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  isContextDefined,\n  lazyBind,\n  defineConstants,\n  symbols,\n  isAbortSignal,\n  global,\n  isAbortController,\n  setImmediate,\n  asap,\n  AbortSignal,\n  AbortController,\n  EventEmitter,\n  AxiosPromise as default\n};\n","export const VERSION = \"0.1.0\";"],"names":["hasOwn","hasOwnProperty","obj","prop","call","Object","prototype","isFunction","thing","_global","globalThis","global","self","window","_setImmediate","setImmediateSupported","setImmediate","postMessageSupported","postMessage","token","Math","random","callbacks","addEventListener","source","data","length","shift","cb","push","setTimeout","asap","queueMicrotask","process","nextTick","functionTypeTest","constructor","name","isGeneratorFunction","isAsyncFunction","async","isPlainFunction","isContextDefined","context","isAbortSignal","aborted","removeEventListener","utils","lazyBind","props","bindMethods","symbols","forEach","symbol","Symbol","descriptor","getOwnPropertyDescriptor","value","get","enumerable","defineProperty","this","resolvedValue","boundContext","apply","arguments","set","v","Error","configurable","console","warn","isGenerator","next","throw","defineConstants","descriptors","getOwnPropertyNames","defineProperties","isAbortController","abort","signal","tags","iterator","kInternals","kSignature","for","CanceledError","message","super","code","static","isCanceledError","err","toUpperCase","replace","addSignature","init","TimeoutError","messageOrTimeout","EventEmitter","events","_events","on","event","listener","prepend","listeners","emit","unshift","off","found","i","splice","args","Array","from","slice","l","once","listenerCount","kSignal","kAborted","kAbort","hasNativeSupport","AbortController","AbortSignal","_AbortSignal","dispatchEvent","type","target","toStringTag","toString","_AbortController","reason","kPromiseSign","kState","kValue","kCallbacks","kDoResolve","kResolveTo","kResolve","kParent","kInnerThenable","kCanceled","kFinalized","kSync","kCallback","kCancelCallbacks","kFinalize","kUnsubscribe","kResolveGenerator","kAtomic","kCanceledWith","kUncaught","kTag","kTimer","ATOMIC_MODE_AWAIT","hasConsole","noop","invokeCallbacks","that","AxiosPromise","executor","timeout","signals","cancel","listen","TypeError","maybeOnCancelSubscriber","onCancel","fn","fnContext","done","e","ms","clearTimeout","tag","String","atomic","mode","promise","then","chain","resolve","uncaught","handler","appendedHandler","forced","parent","undefined","innerThenable","scope","internals","controller","parentCallbacks","callback","isRejected","canceled","cancelCallbacks","hasCallback","uncaughtCallbacks","_unhandledRejection","settled","getMethod","onFulfilled","onRejected","$","$$","invoked","resolver","catch","finally","status","promises","all","map","options","_","reject","chains","results","cancelRequested","subscribed","counter","_reject","timer","generator","result","r","innerPromise","scopeArg","generatorArgs","VERSION","AxiosPromiseSync"],"mappings":"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"}
const{hasOwn:t=(({hasOwnProperty:t})=>(e,n)=>t.call(e,n))(Object.prototype)}=Object,e=t=>"function"==typeof t,n="object"==typeof globalThis&&globalThis||"undefined"!=typeof global&&global||"undefined"!=typeof self&&self||window,r=(s="function"==typeof setImmediate,i=e(n.postMessage),s?setImmediate:i?(o=`axios-promise@${Math.random()}`,l=[],n.addEventListener("message",(({source:t,data:e})=>{t===n&&e===o&&l.length&&l.shift()()}),!1),t=>{l.push(t),n.postMessage(o,"*")}):t=>setTimeout(t));var s,i,o,l;const c="undefined"!=typeof queueMicrotask?queueMicrotask:"undefined"!=typeof process&&process.nextTick||r,a=({constructor:t})=>{const{name:n}=t;return r=>r&&e(r)&&(r.constructor===t||n&&r.constructor.name===n)},h=a((function*(){})),u=a((async()=>{})),f=a((()=>{})),p=t=>null!=t&&t!==n,y=t=>t&&"object"==typeof t&&"boolean"==typeof t.aborted&&e(t.addEventListener)&&e(t.removeEventListener),d={global:n,setImmediate:r,asap:c,isGeneratorFunction:h,isFunction:e,isAsyncFunction:u,isPlainFunction:f,functionTypeTest:a,isContextDefined:p,hasOwn:t,lazyBind:(n,r,{bindMethods:s=!0}={})=>{const i={};return r.forEach((r=>{const o=Symbol(`${r}Lazy`),l=Object.getOwnPropertyDescriptor(n,r),{value:c,get:a,enumerable:h}=l;!("value"in l)||e(c)?(Object.defineProperty(n,r,{get(){if(t.call(this,o))return this[o];const n=a?a.call(this):c,r=this;return this[o]=s&&e(n)?function(){return n.apply(p(this)?this:r,arguments)}:n},set(t){throw Error(`Can not rewrite prop ${r} with ${t}`)},enumerable:h,configurable:!0}),i[r]=o):console.warn("skip",r)})),i},isGenerator:t=>t&&e(t.next)&&e(t.throw),defineConstants:(t,e,{configurable:n=!0,enumerable:r=!0}={})=>{const s={};Object.getOwnPropertyNames(e).forEach((t=>{s[t]={value:e[t],enumerable:r,configurable:n}})),Object.defineProperties(t,s)},isAbortSignal:y,isAbortController:t=>t&&"object"==typeof t&&e(t.abort)&&y(t.signal),symbols:(...t)=>({*[Symbol.iterator](){for(;;)yield Symbol(t.shift()||"")}})},m=Symbol("internals"),g=Symbol.for("AxiosPromise.CanceledError");class b extends Error{constructor(t,e){super(t||"canceled");const n=this.constructor[m];this.name=n.name,this.code=e||n.code}static from(t){return this.isCanceledError(t)?t:new this(t instanceof Error?t.message:t)}static isCanceledError(t){return!(!t||!t[g])}static addSignatureTo(t){"function"==typeof t&&(t.prototype[g]=this[m].code)}static rethrow(t,e){if(this.isCanceledError(t)&&(!e||e===t.code))throw t}static init(t,e){this[m]={name:t,code:e||"ERR_"+t.toUpperCase().replace(/ERROR$/,"")},this.addSignatureTo(this)}}b.init("CanceledError");class v extends b{constructor(t,e){super("number"==typeof t?`${t} ms timeout exceeded`:t,e)}}v.init("TimeoutError");class w{constructor(t){this._events=t||{}}on(t,e,n){const r=this._events,s=r[t];return r.newListener&&this.emit("newListener",t,e),s?"function"==typeof s?r[t]=n?[e,s]:[s,e]:n?e.unshift(e):s.push(e):r[t]=e,this}off(t,e){const n=this._events,r=n[t];let s=!1;if(r)if("function"==typeof r)r===e&&(n[t]=null,s=!0);else{let t=r.length;for(;t--;)if(r[t]===e){r.splice(t,1),s=!0;break}}return s&&n.removeListener&&this.emit("removeListener",t,e),s}emit(t){let e=this._events[t];if(!e)return!1;const n=Array.from(arguments).slice(1);if("function"==typeof e)e.apply(null,n);else{const t=e.length;t>1&&(e=e.slice());for(let r=0;r<t;r++)e[r].apply(null,n)}return!0}once(t,e,n){const r=()=>{this.off(t,r),e.apply(null,arguments)};return this.on(t,r,n)}listenerCount(t){const e=this._events[t];return e?"function"==typeof e?1:e.length:0}}const{prototype:A}=w;A.addEventListener=A.on,A.removeEventListener=A.off;const[E,S,C,T]=d.symbols("signal","aborted","abort","reason"),j="function"==typeof AbortController&&"function"==typeof AbortSignal&&"reason"in(new AbortController).signal,x=j?AbortSignal:class extends w{constructor(){super(),this[S]=!1}get aborted(){return this[S]}get reason(){return this[T]}[C](t){this[S]||(this[S]=!0,this[T]=t,this.dispatchEvent("abort"))}dispatchEvent(t){const e={type:t,target:this};let n;"function"==typeof(n=this["on"+t])&&n.call(this,e),this.emit(t,e)}get[Symbol.toStringTag](){return"AbortSignal"}toString(){return"[object AbortSignal]"}},O=j?AbortController:class{constructor(){this[E]=null}get signal(){return this[E]||(this[E]=new x)}abort(t){this.signal[C](t)}get[Symbol.toStringTag](){return"AbortController"}toString(){return"[object AbortController]"}};class P extends Error{constructor(t,e){super((e?e+": ":"")+t.message,{cause:t}),t.name="UnhandledRejectionError"}}const{isGenerator:L,isFunction:$,isGeneratorFunction:R,isAsyncFunction:F,isPlainFunction:k,isContextDefined:_,lazyBind:I,defineConstants:M,symbols:z,isAbortSignal:G,global:D,setImmediate:q,isAbortController:B,asap:N}=d,U=Symbol.for("AxiosPromise"),[V,W,H,J,K,Q,X,Y,Z,tt,et,nt,rt,st,it,ot,lt,ct,at,ht,ut,ft]=z("state","value","callbacks","doResolve","resolveTo","resolve","parent","innerThenable","canceled","finalized","sync","callback","cancelCallbacks","internals","finalize","unsubscribe","resolveGenerator","atomic","canceledWith","tag","timer","unhandledFlag"),pt=!1,{push:yt}=Array.prototype,dt="undefined"!=typeof console&&console,mt=()=>{},[gt,bt]=((t,e)=>{let n;const r=()=>{n=0;let e,r=t.length;for(let n=0;n<r;n++)(e=t[n]).constructor._unhandledRejection(e[W],e);t=[]};return[s=>{t.push(s),e++,n||(n=setTimeout(r))},r=>{const s=t.indexOf(r);s<0||(--e?t.splice(s,1):(n&&clearTimeout(n),n=0,t=[]))}]})([],0);class vt{constructor(t,{signal:e,timeout:n}={}){if(this[V]=0,this[H]=null,this[st]={signals:null},e){if(e.aborted)return this.cancel(),this;this.listen(e)}let r;if(n&&this.timeout(n),t!==mt){if("function"!=(r=typeof t))return this[K](new TypeError(`Promise resolver ${r} is not a function`)),this;const e=this[J](t);e&&$(e)&&this.onCancel(e)}}[J](t,e){let n=!1;try{return t.call(e,(t=>{n||(n=!0,this[Q](t,!1))}),(t=>{n||(n=!0,this[K](t,!0))}),this)}catch(t){if(n)return;n=!0,this[K](t,!0)}}timeout(t,e){return this[V]||(this[ut]&&(clearTimeout(this[ut]),this[ut]=0),t>0&&(this[ut]=setTimeout((()=>{this[ut]=0,this.cancel(v.from(e||t))}),t))),this}tag(t){return arguments.length?(this[ht]=String(t),this):this[ht]||""}atomic(t=false){const e=this.then();return e[ct]=this[ct]=!!t,e}static atomic(t,e=false){return this.resolve(t,{atomic:e})}cancel(t,e){if(this[tt])return!1;let n,r=this,s=r[ct];for(;void 0===s&&(n=r[X])&&!n[tt]&&(e||"function"==typeof n[H]||n[H].length<=1);)s=n[ct],r=n;if(t=b.from(t),s===pt)return r[at]=t,!0;const i=r[Y];return i&&"function"==typeof i.cancel&&i.cancel(t)||r[Z]||(t.scope=r,r[K](t,!0)),!0}listen(t){if(!this[tt]){if(!G(t))throw TypeError("expected AbortSignal object");const e=this[st];e.signals?e.signals.push(t):e.signals=[t],t.addEventListener("abort",(()=>this.cancel(t.reason)))}return this}onCancel(t){this[rt]?this[rt].push(t):this[rt]=[t]}get signal(){return(this[st].controller=new O).signal}[ot](t){const e=this[H],n=t[nt];if("function"==typeof e&&e===n)this[H]=null;else{let t=e.length;for(;t--;)if(e[t]===n)return e.splice(t,1)}}[it](){this[tt]=!0;let t=this[W],e=2===this[V],n=this[Z];const r=this[st],{signals:s,controller:i}=r,o=this[X];if(!e&&this[at]&&(n=!0,e=!0,t=this[at]),o&&!o[tt]&&o[ot](this),this[ut]&&clearTimeout(this[ut]),s){let t=s.length;for(;t--;)s[t].removeEventListener("abort",this.cancel)}if(n){const e=this[rt];e&&((t,e,n)=>{if(!t)return!1;if("function"==typeof t)return t.apply(n,e),!0;{const{length:r}=t;for(let s=0;s<r;s++)t[s].apply(n,e)}})(e,[t]),i&&i.abort()}const l=this[H];let c;if(l)if("function"==typeof l)c=!0,l(t,e);else{const{length:n}=l;c=n;for(let r=0;r<n;r++)l[r](t,e)}!e||c||n||dt&&true!==this[ct]&&(this[ft]=!0,gt(this)),this[H]=null,this[X]=null,this[rt]=null,this[Y]=null,this[st]=null,this[ut]=null}[K](t,e){if(this[tt])return;const n=this[V];if(e&&b.isCanceledError(t))this[Z]=!0;else if(n)return;this[W]=t,n||(this[V]=e?2:1,this[et]?this[it]():N((()=>this[it]())))}[Q](t,e){const{constructor:n}=this;let r;if(this===t)return this[K](new TypeError(`circular reference to ${t}`),!0);if(t&&L(t))r=(t=n[lt](t,new n(mt))).then;else if(t)try{r=((t,e)=>{let n,r;if(("object"==(n=typeof t)||"function"===n)&&"function"==typeof(r=t[e]))return r})(t,"then")}catch(t){return this[K](t,!0)}r&&"function"==typeof r?(this[Y]=t,this[J](r,t)):this[K](t,e)}then(t,e){return t="function"==typeof t?t:null,e="function"==typeof e?e:null,this[ft]&&bt(this),new this.constructor(((n,r,s)=>{let i;const o=(n,r)=>{if(i)return;i=!0;const o=r?e:t;try{s[Q](o?o(n,s):n,r&&!o)}catch(t){s[K](t,!0)}};if(s[X]=this,this[tt])return this[et]?o(this[W],2===this[V]):N((()=>{o(this[W],2===this[V])}));s[nt]=o;const l=this[H];l?"function"==typeof l?this[H]=[l,o]:l.push(o):this[H]=o}))}catch(t){return this.then(null,t)}finally(t){let{constructor:e}=this;return $(t)?this.then(((n,r)=>e.resolve(t({value:n,status:"fulfilled"},r)).then((()=>n))),((n,r)=>e.resolve(t({reason:n,status:"rejected"},r)).then((()=>{throw n})))):this.then(t,t)}static allSettled(t){return this.all(Array.from(t).map((t=>t.then((t=>({status:"fulfilled",value:t})),(t=>({status:"rejected",reason:t}))))))}get[Symbol.toStringTag](){return"AxiosPromise"}toString(){const t=this[ht];return`${this[Symbol.toStringTag]}${t?"#"+t:""}{${["pending","fulfilled","rejected"][this[V]]}}`}static resolve(t,e){const n=null!=e?!!e.atomic:void 0;if(t instanceof this&&t[et]===this[et]&&t[ct]===n)return t;const r=new this((e=>e(t)));return n&&(r[ct]=n),r}static reject(t){return new this(((e,n)=>n(t)))}static all(t){return new this(((e,n,{onCancel:r})=>{const{length:s}=t=Array.from(t);if(!s)return void e([]);const i=new Array(s),o=new Array(s);let l,c,a,h=0;const u=t=>{if(c){a=!0;for(let e=0;e<s;e++)i[e].cancel(t)}else l=!0},f=t=>{n(t),!a&&u()};for(let n=0;n<s;n++)i[n]=this.resolve(t[n]).then((t=>{o[n]=t,++h===s&&e(t)}),f);c=!0,l?u():r(u)}))}static race(t){return new this(((e,n,{onCancel:r})=>{const{length:s}=t=Array.from(t);if(!s)return;const i=new Array(s);let o,l,c;const a=t=>{if(l){c=!0;for(let e=0;e<s;e++)i[e].cancel(t)}else o=!0},h=t=>{try{n(t)}finally{!c&&a()}};for(let n=0;n<s;n++)i[n]=this.resolve(t[n]).then((t=>{e(t),!c&&a()}),h);l=!0,o?a():r(a)}))}static delay(t,e){return new this(((n,r,{onCancel:s})=>{const i=setTimeout(n,t,e);s((()=>clearTimeout(i)))}))}static isCanceledError(t){return b.isCanceledError(t)}static isAxiosPromise(t){return!(!t||!t[U])}static[lt](t,e){const n=n=>{try{s(t.next(n))}catch(t){e[K](t,!0)}},r=n=>{try{s(t.throw(n))}catch(t){e[K](t,!0)}},s=t=>{if(t.done)return e[Q](t.value);const s=this.resolve(t.value).then(n,r);return e[Y]=s,s};return n(),e}static _unhandledRejection(t,e){const n=e[ht]?`@[${e[ht]}]`:"";console.error(new P(t,n))}static promisify(t,{scopeArg:e=!1,scopeContext:n=!1}={}){if(t&&t[U])return t;if(!$(t))throw TypeError("value must be a function");let r;const s=this;return r=R(t)?function(){return new s(((r,i,o)=>{let l;e?(l=[o],yt.apply(l,arguments)):l=arguments,s[lt](t.apply(n||!this||this===D?o:this,l),o)}))}:function(){try{return s.resolve(t.apply(this,arguments))}catch(t){return s.reject(t)}},r[U]=!0,r.original=t,r}static promisifyAll(t,{reducer:e,...n}={}){const r=Object.getOwnPropertyDescriptors(t);let s,i;Object.entries(r).forEach((([r,o])=>{"value"in o&&R(i=o.value)&&o.configurable&&(!e||(s=e.call(t,r,i)))&&Object.defineProperty(t,s||r,{...o,value:this.promisify(i,n)})}))}}const{prototype:wt}=vt;wt[et]=!1,I(wt,["cancel","onCancel","signal"]),I(vt,["delay","promisify"]),M(vt,{VERSION:"0.10.0",AbortController:O,AbortSignal:x,CanceledError:b,TimeoutError:v});class At extends vt{get[Symbol.toStringTag](){return"AxiosPromiseSync"}}At.prototype[et]=!0;export{O as AbortController,x as AbortSignal,vt as AxiosPromise,At as AxiosPromiseSync,b as CanceledError,w as EventEmitter,v as TimeoutError,N as asap,vt as default,M as defineConstants,D as global,B as isAbortController,G as isAbortSignal,F as isAsyncFunction,_ as isContextDefined,L as isGenerator,R as isGeneratorFunction,k as isPlainFunction,I as lazyBind,q as setImmediate,z as symbols};
//# sourceMappingURL=axios-promise.min.js.map

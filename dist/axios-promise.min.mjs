const{hasOwn:t=(({hasOwnProperty:t})=>(e,n)=>t.call(e,n))(Object.prototype)}=Object,e=t=>"function"==typeof t,n="object"==typeof globalThis&&globalThis||"undefined"!=typeof global&&global||"undefined"!=typeof self&&self||window,s=(r="function"==typeof setImmediate,i=e(n.postMessage),r?setImmediate:i?(o=`axios-promise@${Math.random()}`,l=[],n.addEventListener("message",(({source:t,data:e})=>{t===n&&e===o&&l.length&&l.shift()()}),!1),t=>{l.push(t),n.postMessage(o,"*")}):t=>setTimeout(t));var r,i,o,l;const c="undefined"!=typeof queueMicrotask?queueMicrotask:"undefined"!=typeof process&&process.nextTick||s,a=({constructor:t})=>n=>n&&e(n)&&n.constructor===t,h=a((function*(){})),u=a((async()=>{})),f=a((()=>{})),p=t=>null!=t&&t!==n,y=t=>t&&"object"==typeof t&&"boolean"==typeof t.aborted&&e(t.addEventListener)&&e(t.removeEventListener),d={global:n,setImmediate:s,asap:c,isGeneratorFunction:h,isAsyncFunction:u,isPlainFunction:f,functionTypeTest:a,isContextDefined:p,hasOwn:t,lazyBind:(n,s,{bindMethods:r=!0}={})=>{const i={};return s.forEach((s=>{const o=Symbol(`${s}Lazy`),l=Object.getOwnPropertyDescriptor(n,s),{value:c,get:a,enumerable:h}=l;!("value"in l)||e(c)?(Object.defineProperty(n,s,{get(){if(t.call(this,o))return this[o];const n=a?a.call(this):c,s=this;return this[o]=r&&e(n)?function(){return n.apply(p(this)?this:s,arguments)}:n},set(t){throw Error(`Can not rewrite prop ${s} with ${t}`)},enumerable:h,configurable:!0}),i[s]=o):console.warn("skip",s)})),i},isGenerator:t=>t&&e(t.next)&&e(t.throw),defineConstants:(t,e,{configurable:n=!0,enumerable:s=!0}={})=>{const r={};Object.getOwnPropertyNames(e).forEach((t=>{r[t]={value:e[t],enumerable:s,configurable:n}})),Object.defineProperties(t,r)},isAbortSignal:y,isAbortController:t=>t&&"object"==typeof t&&e(t.abort)&&y(t.signal),symbols:(...t)=>({*[Symbol.iterator](){for(;;)yield Symbol(t.shift()||"")}})},g=Symbol("internals"),m=Symbol.for("AxiosPromise.CanceledError");class b extends Error{constructor(t){super(t||"canceled");const{name:e,code:n}=this.constructor[g];this.name=e,this.code=n}static from(t){return this.isCanceledError(t)?t:new this(t instanceof Error?t.message:"")}static isCanceledError(t){return!(!t||!t[m])}static addSignature(t){"function"==typeof t&&(t.prototype[m]=this[g].code)}static rethrow(t,e){if(this.isCanceledError(t)&&(!e||e===t.code))throw t}static init(t,e){this[g]={name:t,code:e||"ERR_"+t.toUpperCase().replace(/ERROR$/,"")},this.addSignature(this)}}b.init("CanceledError");class v extends b{constructor(t){super("number"==typeof t?`${t} ms timeout exceeded`:t)}}v.init("TimeoutError");class w{constructor(t){this._events=t||{}}on(t,e,n){const s=this._events,r=s[t];return s.newListener&&this.emit("newListener",t,e),r?"function"==typeof r?s[t]=n?[e,r]:[r,e]:n?e.unshift(e):r.push(e):s[t]=e,this}off(t,e){const n=this._events,s=n[t];let r=!1;if(s)if("function"==typeof s)s===e&&(n[t]=null,r=!0);else{let t=s.length;for(;t--;)if(s[t]===e){s.splice(t,1),r=!0;break}}return r&&n.removeListener&&this.emit("removeListener",t,e),r}emit(t){const e=this._events[t];if(!e)return!1;const n=Array.from(arguments).slice(1);if("function"==typeof e)e.apply(null,n);else{const t=e.length;for(let s=0;s<t;s++)e.apply(null,n)}return!0}once(t,e,n){const s=()=>{this.off(t,s),e.apply(null,arguments)};return this.on(t,s,n)}listenerCount(t){const e=this._events[t];return e?"function"==typeof e?1:e.length:0}}const{prototype:A}=w;A.addEventListener=A.on,A.removeEventListener=A.off;const[E,S,C,T]=d.symbols("signal","aborted","abort","events"),j="function"==typeof AbortController&&"function"==typeof AbortSignal,x=j?AbortSignal:class extends w{constructor(){super(),this[S]=!1}get aborted(){return this[S]}[C](){this[S]||(this[S]=!0,this.dispatchEvent("abort"))}dispatchEvent(t){const e={type:t,target:this};let n;"function"==typeof(n=this["on"+t])&&n.call(this,e),this[T].emit(t,e)}get[Symbol.toStringTag](){return"AbortSignal"}toString(){return"[object AbortSignal]"}},O=j?AbortController:class{constructor(){this[E]=null}get signal(){return this[E]||(this[E]=new x)}abort(t){this.signal[C](t)}get[Symbol.toStringTag](){return"AbortController"}toString(){return"[object AbortController]"}},{isGenerator:L,isGeneratorFunction:P,isFunction:$,lazyBind:M,asap:_,defineConstants:D,symbols:k,isAbortSignal:I}=d,R=Symbol.for("AxiosPromise"),[z,F,G,B,q,U,W,H,N,J,K,Q,V,X,Y,Z,tt,et,nt,st,rt,it,ot]=k("state","value","callbacks","doResolve","resolveTo","resolve","parent","innerThenable","canceled","finalized","sync","callback","cancelCallbacks","internals","finalize","unsubscribe","resolveGenerator","atomic","canceledWith","uncaught","tag","unhandledRejection","timer"),{push:lt}=Array.prototype,ct="undefined"!=typeof console&&console,at=()=>{},ht=(t,e,n)=>{if(!t)return!1;if("function"==typeof t)return t.apply(n,e),!0;{const{length:s}=t;for(let r=0;r<s;r++)t[r].apply(n,e);return!!s}};class ut{constructor(t,{signal:e,timeout:n}={}){if(this[z]=0,this[G]=null,this[X]={signals:null},e){if(e.aborted)return this.cancel(),this;this.listen(e)}let s;if(n&&this.timeout(n),t!==at){if("function"!=(s=typeof t))return this[q](new TypeError(`Promise resolver ${s} is not a function`)),this;this[B](t)}}[B](t,e){let n=!1;try{return t.call(e,(t=>{n||(n=!0,this[U](t,!1))}),(t=>{n||(n=!0,this[q](t,!0))}),this)}catch(t){if(n)return;n=!0,this[q](t,!0)}}timeout(t){return this[z]||(this[ot]&&(clearTimeout(this[ot]),this[ot]=0),t>0&&(this[ot]=setTimeout((()=>{this[ot]=0,this.cancel(new v(t))}),t))),this}tag(t){return arguments.length?(this[rt]=String(t),this):this[rt]||""}atomic(t=1){const e=this.then();return e[et]=this[et]=t,e}static atomic(t,e=1){return this.resolve(t,{atomic:e})}uncaught(t=at){const e=this[st];return this[st]=e&&e!==at?[e,t]:t,this}cancel(t,e){if(this[J])return!1;let n,s=this,r=s[et];for(;!r&&(n=s[W])&&!n[J]&&(e||"function"==typeof n[G]||n[G].length<=1);)r=n[et],s=n;if(t=b.from(t),1===r)return s[nt]=t,!0;const i=s[H];return i&&"function"==typeof i.cancel&&i.cancel(t)||s[N]||(t.scope=s,s[q](t,!0)),!0}listen(t){if(!I(t))throw TypeError("expected AbortSignal object");const e=this[X];return e.signals?e.signals.push(t):e.signals=[t],t.addEventListener("abort",(()=>this.cancel())),this}onCancel(t){this[V]?this[V].push(t):this[V]=[t]}get signal(){return(this[X].controller=new O).signal}[Z](t){const e=this[G],n=t[Q];if("function"==typeof e&&e===n)this[G]=null;else{let t=e.length;for(;t--;)if(e[t]===n)return e.splice(t,1)}}[Y](){this[J]=!0;let t=this[F],e=2===this[z],n=this[N];const s=this[X],{signals:r,controller:i}=s,o=this[W];if(!e&&this[nt]&&(n=!0,e=!0,t=this[nt]),o&&!o[J]&&o[Z](this),this[ot]&&clearTimeout(this[ot]),r){let t=r.length;for(;t--;)r[t].removeEventListener("abort",this.cancel)}if(n){const e=this[V];e&&ht(e,[t]),i&&i.abort()}const l=this[G];let c;if(l)if("function"==typeof l)c=!0,l(t,e);else{const{length:n}=l;c=n;for(let s=0;s<n;s++)l[s](t,e)}if(e&&!c&&!n){const e=this[st];e?e!==at&&ht(e,[t]):ct&&2!==this[et]&&this.constructor[it](t)}this[G]=null,this[W]=null,this[V]=null,this[H]=null,this[X]=null,this[st]=null,this[ot]=null}[q](t,e){if(this[J])return;const n=this[z];if(e&&b.isCanceledError(t))this[N]=!0;else if(n)return;this[F]=t,n||(this[z]=e?2:1,this[K]?this[Y]():_((()=>this[Y]())))}[U](t,e){const{constructor:n}=this;let s;if(this===t)return this[q](new TypeError(`circular reference to ${t}`),!0);if(t&&L(t))s=(t=n[tt](t,new n(at))).then;else if(t)try{s=((t,e)=>{let n,s;if(("object"==(n=typeof t)||"function"===n)&&"function"==typeof(s=t[e]))return s})(t,"then")}catch(t){return this[q](t,!0)}s&&"function"==typeof s?(this[H]=t,this[B](s,t)):this[q](t,e)}then(t,e){return t="function"==typeof t?t:null,e="function"==typeof e?e:null,new this.constructor(((n,s,r)=>{let i;const o=(n,s)=>{if(i)return;i=!0;const o=s?e:t;try{r[U](o?o(n,r):n,s&&!o)}catch(t){r[q](t,!0)}};if(r[W]=this,this[J])return this[K]?o(this[F],2===this[z]):_((()=>{o(this[F],2===this[z])}));r[Q]=o;const l=this[G];l?"function"==typeof l?this[G]=[l,o]:l.push(o):this[G]=o}))}catch(t){return this.then(null,t)}finally(t){let{constructor:e}=this;return $(t)?this.then(((n,s)=>e.resolve(t({value:n,status:"fulfilled"},s)).then((()=>n))),((n,s)=>e.resolve(t({reason:n,status:"rejected"},s)).then((()=>{throw n})))):this.then(t,t)}static allSettled(t){return this.all(Array.from(t).map((t=>t.then((t=>({status:"fulfilled",value:t})),(t=>({status:"rejected",reason:t}))))))}get[Symbol.toStringTag](){return"AxiosPromise"}toString(){const t=this[rt];return`${this[Symbol.toStringTag]}${t?"#"+t:""}{${["pending","fulfilled","rejected"][this[z]]}}`}static resolve(t,e){const n=null!=e&&e.atomic||0;if(t instanceof this&&t[K]===this[K]&&t[et]===n)return t;const s=new this((e=>e(t)));return n&&(s[et]=n),s}static reject(t){return new this(((e,n)=>n(t)))}static all(t){return new this(((e,n,{onCancel:s})=>{const{length:r}=t=Array.from(t);if(!r)return void e([]);const i=new Array(r),o=new Array(r);let l,c,a,h=0;const u=t=>{if(c){a=!0;for(let e=0;e<r;e++)i[e].cancel(t)}else l=!0},f=t=>{n(t),!a&&u()};for(let n=0;n<r;n++)i[n]=this.resolve(t[n]).then((t=>{o[n]=t,++h===r&&e(t)}),f);c=!0,l?u():s(u)}))}static race(t){return new this(((e,n,{onCancel:s})=>{const{length:r}=t=Array.from(t);if(!r)return;const i=new Array(r);let o,l,c;const a=t=>{if(l){c=!0;for(let e=0;e<r;e++)i[e].cancel(t)}else o=!0},h=t=>{try{n(t)}finally{!c&&a()}};for(let n=0;n<r;n++)i[n]=this.resolve(t[n]).then((t=>{e(t),!c&&a()}),h);l=!0,o?a():s(a)}))}static delay(t,e){return new this(((n,s,{onCancel:r})=>{const i=setTimeout(n,t,e);r((()=>clearTimeout(i)))}))}static isCanceledError(t){return b.isCanceledError(t)}static isAxiosPromise(t){return!(!t||!t[R])}static[tt](t,e){const n=n=>{try{r(t.next(n))}catch(t){e[q](t,!0)}},s=n=>{try{r(t.throw(n))}catch(t){e[q](t,!0)}},r=t=>{if(t.done)return e[U](t.value);const r=this.resolve(t.value).then(n,s);return e[H]=r,r};return n(),e}static[it](t){const e=this[rt]?` @ ${this[rt]}`:"";console.warn(`Unhandled AxiosPromise Rejection${e}:`,t)}static promisify(t,{scopeArg:e=!1}={}){if(!P(t))throw new TypeError("value must be a generator function");const n=this;return function(){return new n(((s,r,i)=>{let o;e?(o=[i],lt.apply(o,arguments)):o=arguments,n[tt](t.apply(this,o),i)}))}}}const{prototype:ft}=ut;ft[K]=!1,M(ft,["cancel","onCancel","signal"]),M(ut,["delay","promisify"]);class pt extends ut{get[Symbol.toStringTag](){return"AxiosPromiseSync"}}pt.prototype[K]=!0,D(ft,{CanceledError:b,TimeoutError:v}),D(ut,{ATOMIC_MODE_DETACHED:2,ATOMIC_MODE_AWAIT:1,ATOMIC_MODE_DISABLED:0});export{O as AbortController,x as AbortSignal,ut as AxiosPromise,pt as AxiosPromiseSync,w as EventEmitter,d as utils};
//# sourceMappingURL=axios-promise.min.mjs.map

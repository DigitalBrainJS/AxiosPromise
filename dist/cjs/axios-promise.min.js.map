{"version":3,"file":"axios-promise.min.js","sources":["../../lib/utils.js","../../lib/CanceledError.js","../../lib/TimeoutError.js","../../lib/EventEmitter.js","../../lib/AbortController.js","../../lib/UnhandledRejectionError.js","../../lib/index.js","../../lib/env/data.js"],"sourcesContent":["const {\n  hasOwn = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype)\n} = Object;\n\nconst {toStringTag} = Symbol;\n\nconst isFunction = (thing) => typeof thing === 'function';\n\nconst _global = typeof globalThis === 'object' && globalThis ||\n  (typeof global !== \"undefined\" && global) ||\n  (typeof self !== \"undefined\" && self) || window\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios-promise@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\nconst functionTypeTest = ({constructor}) => {\n  const {name} = constructor;\n  return (thing) => thing && isFunction(thing) && (thing.constructor === constructor || (name && thing.constructor.name === name));\n}\n\nconst isGeneratorFunction = functionTypeTest(function* () {});\n\nconst isAsyncFunction = functionTypeTest(async () => {});\n\nconst isPlainFunction = functionTypeTest(() => {});\n\nconst isGenerator = (obj) =>\n  obj && typeof obj === 'object' && typeof obj.next === 'function' && typeof obj.throw === 'function' &&\n  obj[toStringTag] === 'Generator';\n\nconst isContextDefined = (context) => context != null && context !== _global;\n\nconst lazyBind = (obj, props, {bindMethods = true} = {}) => {\n  const symbols = {};\n\n  props.forEach(prop => {\n    const symbol = Symbol(`${prop}Lazy`);\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    const {value, get, enumerable} = descriptor;\n\n    if('value' in descriptor && !isFunction(value)) {\n      console.warn('skip', prop);\n      return;\n    }\n\n    Object.defineProperty(obj, prop, {\n      get() {\n        if (hasOwn.call(this, symbol)) {\n          return this[symbol];\n        }\n\n        const resolvedValue = get ? get.call(this) : value;\n\n        const boundContext = this;\n\n        return this[symbol] = bindMethods && isFunction(resolvedValue) ? function () {\n          return resolvedValue.apply(isContextDefined(this) ? this : boundContext, arguments);\n        } : resolvedValue;\n      },\n\n      set(v) {\n        throw Error(`Can not rewrite prop ${prop} with ${v}`);\n      },\n\n      enumerable,\n      configurable: true\n    });\n\n    symbols[prop] = symbol;\n  });\n\n  return symbols;\n}\n\nconst defineConstants = (obj, props, {configurable = true, enumerable = true} = {}) => {\n  const descriptors = {};\n\n  Object.getOwnPropertyNames(props).forEach((prop) => {\n    descriptors[prop] = {value: props[prop], enumerable, configurable}\n  })\n\n  Object.defineProperties(obj, descriptors);\n};\n\nconst isAbortSignal = (thing) => {\n  return thing &&\n    typeof thing === 'object' &&\n    typeof thing.aborted === 'boolean' &&\n    isFunction(thing.addEventListener) &&\n    isFunction(thing.removeEventListener);\n}\n\nconst isAbortController = (thing) => {\n  return thing && typeof thing === 'object' && isFunction(thing.abort) && isAbortSignal(thing.signal);\n};\n\nconst symbols = (...tags) => ({\n  * [Symbol.iterator]() {\n    while (true) {\n      yield Symbol(tags.shift() || '');\n    }\n  }\n})\n\nexport default {\n  global: _global,\n  setImmediate: _setImmediate,\n  asap,\n  isGeneratorFunction,\n  isFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  functionTypeTest,\n  isContextDefined,\n  hasOwn,\n  lazyBind,\n  isGenerator,\n  defineConstants,\n  isAbortSignal,\n  isAbortController,\n  symbols\n}\n","const kInternals = Symbol('internals');\nconst kSignature = Symbol.for(`AxiosPromise.CanceledError`);\n\nexport class CanceledError extends Error {\n  constructor(message, code) {\n    super(message || 'This operation was aborted');\n    const internal = this.constructor[kInternals];\n    this.name = internal.name;\n    this.code = code || internal.code;\n  }\n\n  static from(thing) {\n    return this.isCanceledError(thing) ? thing :\n      new this(thing instanceof Error ? (thing.name !== 'AbortError' ? thing.message : '') : thing);\n  }\n\n  static isCanceledError(err) {\n    return !!(err && err[kSignature]);\n  }\n\n  static addSignatureTo(constructor) {\n    typeof constructor === 'function' && (constructor.prototype[kSignature] = this[kInternals].code);\n  }\n\n  static rethrow(err, code) {\n    if (this.isCanceledError(err) && (!code || code === err.code)) {\n      throw err;\n    }\n  }\n\n  static init(name, code) {\n    this[kInternals] = {\n      name,\n      code: code || 'ERR_' + name.toUpperCase().replace(/ERROR$/, '')\n    }\n\n    this.addSignatureTo(this);\n  }\n}\n\nCanceledError.init('CanceledError');\n","import {CanceledError} from './CanceledError.js';\n\nexport class TimeoutError extends CanceledError {\n  constructor(messageOrTimeout, code) {\n    super(typeof messageOrTimeout === 'number' ? `${messageOrTimeout} ms timeout exceeded` : messageOrTimeout, code);\n  }\n}\n\nTimeoutError.init('TimeoutError');\n\n","export default class EventEmitter {\n  constructor(events) {\n    this._events = events || {};\n  }\n\n  on(event, listener, prepend) {\n    const events = this._events\n    const listeners = events[event];\n\n    events['newListener'] && this.emit('newListener', event, listener);\n\n    if (!listeners) {\n      events[event] = listener\n    } else if (typeof listeners === 'function') {\n      events[event] = prepend ? [listener, listeners] : [listeners, listener];\n    } else {\n      prepend ? listener.unshift(listener) : listeners.push(listener);\n    }\n\n    return this;\n  }\n\n  off(event, listener) {\n    const events = this._events\n    const listeners = events[event];\n    let found = false;\n\n    if (listeners) {\n      if (typeof listeners === 'function') {\n        if (listeners === listener) {\n          events[event] = null;\n          found = true;\n        }\n      } else {\n        let i = listeners.length;\n        while (i--) {\n          if (listeners[i] === listener) {\n            listeners.splice(i, 1);\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    found && events['removeListener'] && this.emit('removeListener', event, listener);\n\n    return found;\n  }\n\n  emit(event) {\n    let listeners = this._events[event];\n    if (!listeners) return false;\n\n    const args = Array.from(arguments).slice(1);\n\n    if (typeof listeners === 'function') {\n      listeners.apply(null, args);\n    } else {\n      const l = listeners.length;\n      l > 1 && (listeners = listeners.slice());\n      for (let i = 0; i < l; i++) {\n        listeners[i].apply(null, args);\n      }\n    }\n    return true;\n  }\n\n  once(event, listener, prepend) {\n    const once = () => {\n      this.off(event, once);\n      listener.apply(null, arguments);\n    };\n\n    return this.on(event, once, prepend);\n  }\n\n  listenerCount(event) {\n    const listeners = this._events[event];\n    return listeners ? (typeof listeners === 'function' ? 1 : listeners.length) : 0;\n  }\n}\n\nconst {prototype} = EventEmitter;\n\nprototype.addEventListener = prototype.on;\nprototype.removeEventListener = prototype.off;\n","import utils from './utils.js';\nimport EventEmitter from \"./EventEmitter.js\";\n\nconst [kSignal, kAborted, kAbort, kReason] = utils.symbols('signal', 'aborted', 'abort', 'reason');\n\nconst hasNativeSupport = typeof AbortController === 'function'\n  && typeof AbortSignal === 'function' && 'reason' in new AbortController().signal;\n\nconst _AbortSignal = hasNativeSupport ? AbortSignal : class AbortSignal extends EventEmitter{\n  constructor() {\n    super();\n    this[kAborted] = false;\n  }\n\n  get aborted() {\n    return this[kAborted];\n  }\n\n  get reason() {\n    return this[kReason];\n  }\n\n  [kAbort](reason) {\n    if (!this[kAborted]) {\n      this[kAborted] = true;\n      this[kReason] = reason;\n      this.dispatchEvent('abort');\n    }\n  }\n\n  dispatchEvent(type) {\n    const event = {\n      type,\n      target: this\n    };\n\n    let listener;\n\n    typeof (listener = this['on' + type]) === 'function' && listener.call(this, event);\n\n    this.emit(type, event)\n  }\n\n  throwIfAborted() {\n    if (this[kAborted]) {\n      throw this[kReason];\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AbortSignal'\n  }\n\n  toString() {\n    return '[object AbortSignal]'\n  }\n}\n\nconst _AbortController = hasNativeSupport ? AbortController : class AbortControllerPolyfill {\n  constructor() {\n    this[kSignal] = null;\n  }\n\n  get signal() {\n    return this[kSignal] || (this[kSignal] = new _AbortSignal());\n  }\n\n  abort(reason) {\n    this.signal[kAbort](reason);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AbortController'\n  }\n\n  toString() {\n    return '[object AbortController]'\n  }\n}\n\nexport {\n  _AbortController as AbortController,\n  _AbortSignal as AbortSignal,\n}\n","export default class UnhandledRejectionError extends Error{\n  constructor(err, message) {\n    super((message ? message + ': ' : '') + (err.message || err), {cause: err});\n    this.name = 'UnhandledRejectionError';\n  }\n}\n","import utils from './utils.js';\nimport {CanceledError} from \"./CanceledError.js\";\nimport {TimeoutError} from \"./TimeoutError.js\";\nimport {AbortController, AbortSignal} from \"./AbortController.js\"\nimport EventEmitter from \"./EventEmitter.js\";\nimport {VERSION} from \"./env/data.js\";\nimport UnhandledRejectionError from \"./UnhandledRejectionError.js\";\n\nconst {\n  isGenerator,\n  isFunction,\n  isGeneratorFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  isContextDefined,\n  lazyBind,\n  defineConstants,\n  symbols,\n  isAbortSignal,\n  global,\n  setImmediate,\n  isAbortController,\n  asap,\n  drop\n} = utils;\n\nconst kPromiseSign = Symbol.for('AxiosPromise');\n\nconst [\n  kState,\n  kValue,\n  kCallbacks,\n  kDoResolve,\n  kResolveTo,\n  kResolve,\n  kParent,\n  kInnerThenable,\n  kCanceled,\n  kFinalized,\n  kSync,\n  kCallback,\n  kCancelCallbacks,\n  kInternals,\n  kFinalize,\n  kUnsubscribe,\n  kResolveGenerator,\n  kAtomic,\n  kCanceledWith,\n  kTag,\n  kTimer,\n  kUnhandledFlag\n] = symbols(\n  'state',\n  'value',\n  'callbacks',\n  'doResolve',\n  'resolveTo',\n  'resolve',\n  'parent',\n  'innerThenable',\n  'canceled',\n  'finalized',\n  'sync',\n  'callback',\n  'cancelCallbacks',\n  'internals',\n  'finalize',\n  'unsubscribe',\n  'resolveGenerator',\n  'atomic',\n  'canceledWith',\n  'tag',\n  'timer',\n  'unhandledFlag'\n);\n\nconst STATE_PENDING = 0;\nconst STATE_FULFILLED = 1;\nconst STATE_REJECTED = 2;\n\nconst ATOMIC_MODE_AWAIT = false;\nconst ATOMIC_MODE_DETACHED = true;\n\nconst {push} = Array.prototype;\n\nconst hasConsole = typeof console !== 'undefined' && console;\n\nconst noop = () => {};\n\nconst getThen = (obj) => {\n  let type;\n  let then;\n\n  if(((type = typeof obj) === 'object' || type === 'function') && typeof (then = obj.then) === 'function') {\n    return then;\n  }\n}\n\nconst invokeCallbacks = (callbacks, args, that) => {\n  if(!callbacks) return false;\n\n  if (typeof callbacks === 'function') {\n    callbacks.apply(that, args);\n    return true;\n  } else {\n    const {length} = callbacks;\n    for (let i = 0; i < length; i++) {\n      callbacks[i].apply(that, args);\n    }\n    return !!length;\n  }\n}\n\nconst [trackUnhandled, untrackUnhandled] = ((trackQueue, length) => {\n  let timer;\n\n  const handler = () => {\n    timer = 0;\n    let l = trackQueue.length;\n    let p;\n    for (let i = 0; i < l; i++) {\n      (p = trackQueue[i]).constructor._unhandledRejection(p[kValue], p);\n    }\n    trackQueue = [];\n  }\n\n  return [(promise) => {\n    trackQueue.push(promise);\n    length++;\n    timer || (timer = setTimeout(handler));\n  }, (promise) => {\n    const index = trackQueue.indexOf(promise);\n    if (index < 0) return;\n    length--;\n    if (!length) {\n      timer && clearTimeout(timer);\n      timer = 0;\n      trackQueue = [];\n    } else {\n      trackQueue.splice(index, 1);\n    }\n  }];\n})([], 0);\n\nexport class AxiosPromise {\n  constructor(executor, {signal, timeout} = {}) {\n    this[kState] = STATE_PENDING;\n    this[kCallbacks] = null;\n    this[kInternals] = {\n      signals: null\n    }\n\n    if (signal) {\n      if (signal.aborted) {\n        this.cancel(signal.reason);\n        return this;\n      }\n\n      this.listen(signal);\n    }\n\n    timeout && this.timeout(timeout);\n\n    let type;\n\n    if (executor !== noop) {\n      if ((type = typeof executor) !== 'function') {\n        this[kResolveTo](new TypeError(`Promise resolver ${type} is not a function`));\n        return this;\n      }\n\n      const maybeOnCancelSubscriber = this[kDoResolve](executor);\n\n      if (maybeOnCancelSubscriber && isFunction(maybeOnCancelSubscriber)) {\n        this.onCancel(maybeOnCancelSubscriber);\n      }\n    }\n  }\n\n  [kDoResolve](fn, fnContext) {\n    let done = false;\n\n    try {\n      return fn.call(fnContext,\n        (value) => {\n          if (done) return;\n          done = true;\n          this[kResolve](value, false);\n        }, (reason) => {\n          if (done) return;\n          done = true;\n          this[kResolveTo](reason, true);\n        }, this);\n    } catch (e) {\n      if (done) return;\n      done = true;\n      this[kResolveTo](e, true);\n    }\n  }\n\n  timeout(ms, errorOrMessage) {\n    if (!this[kState]) {\n      if (this[kTimer]) {\n        clearTimeout(this[kTimer]);\n        this[kTimer] = 0;\n      }\n\n      if (ms > 0) {\n        this[kTimer] = setTimeout(() => {\n          this[kTimer] = 0;\n          this.cancel(TimeoutError.from(errorOrMessage || ms))\n        }, ms);\n      }\n    }\n    return this;\n  }\n\n  tag(tag) {\n    if (!arguments.length) {\n      return this[kTag] || '';\n    }\n    this[kTag] = String(tag);\n    return this;\n  }\n\n  atomic(mode = ATOMIC_MODE_AWAIT) {\n    const promise = this.then();\n\n    promise[kAtomic] = (this[kAtomic] = !!mode);\n\n    return promise;\n  }\n\n  static atomic(chain, mode = ATOMIC_MODE_AWAIT) {\n    return this.resolve(chain, {atomic: mode})\n  }\n\n  cancel(reason, forced) {\n    if (this[kFinalized]) return false;\n\n    let target = this;\n    let parent;\n    let atomic = target[kAtomic];\n\n    while (atomic === undefined && (parent = target[kParent]) && !parent[kFinalized] && (forced || typeof parent[kCallbacks] === 'function' || parent[kCallbacks].length <= 1)) {\n      atomic = parent[kAtomic]\n      target = parent;\n    }\n\n    reason = CanceledError.from(reason);\n\n    if (atomic === ATOMIC_MODE_AWAIT) {\n      target[kCanceledWith] = reason;\n      return true;\n    }\n\n    const innerThenable = target[kInnerThenable];\n\n    if (!(innerThenable && typeof innerThenable.cancel === 'function' && innerThenable.cancel(reason)) && !target[kCanceled]) {\n      reason.scope = target;\n      target[kResolveTo](reason, true);\n    }\n\n    return true;\n  }\n\n  listen(signal) {\n    if (signal != null && !this[kFinalized]) {\n      if (!isAbortSignal(signal)) {\n        throw TypeError('expected AbortSignal object');\n      }\n\n      const internals = this[kInternals];\n\n      if (internals.signals) {\n        internals.signals.push(signal);\n      } else {\n        internals.signals = [signal];\n      }\n\n      signal.addEventListener('abort', () => this.cancel(signal.reason));\n    }\n\n    return this;\n  }\n\n  onCancel(listener) {\n    this[kCancelCallbacks] ? this[kCancelCallbacks].push(listener) : this[kCancelCallbacks] = [listener];\n  }\n\n  get signal() {\n    return (this[kInternals].controller = new AbortController()).signal;\n  }\n\n  [kUnsubscribe](chain) {\n    const parentCallbacks = this[kCallbacks];\n    const callback = chain[kCallback];\n    if (typeof parentCallbacks === 'function' && parentCallbacks === callback) {\n      this[kCallbacks] = null;\n    } else {\n      let i = parentCallbacks.length;\n      while (i--) {\n        if (parentCallbacks[i] === callback) {\n          return parentCallbacks.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  [kFinalize]() {\n    this[kFinalized] = true;\n\n    let value = this[kValue];\n    let isRejected = this[kState] === STATE_REJECTED;\n    let canceled = this[kCanceled];\n    const internals = this[kInternals];\n    const {signals, controller} = internals;\n    const parent = this[kParent];\n\n    if (!isRejected && this[kCanceledWith]) {\n      canceled = true;\n      isRejected = true;\n      value = this[kCanceledWith];\n    }\n\n    if (parent && !parent[kFinalized]) { // Premature resolving - unsubscribe from parent chain\n      parent[kUnsubscribe](this);\n    }\n\n    this[kTimer] && clearTimeout(this[kTimer]);\n\n    if (signals) {\n      let i = signals.length;\n      while (i--) {\n        signals[i].removeEventListener('abort', this.cancel);\n      }\n    }\n\n    if (canceled) {\n      const cancelCallbacks = this[kCancelCallbacks];\n\n      if (cancelCallbacks) {\n        invokeCallbacks(cancelCallbacks, [value]);\n      }\n\n      controller && controller.abort(value);\n    }\n\n    const callbacks = this[kCallbacks];\n\n    let hasCallback;\n\n    if (callbacks) {\n      if (typeof callbacks === 'function') {\n        hasCallback = true;\n        callbacks(value, isRejected);\n      } else {\n        const {length} = callbacks;\n        hasCallback = length;\n        for (let i = 0; i < length; i++) {\n          callbacks[i](value, isRejected);\n        }\n      }\n    }\n\n    if (isRejected && !hasCallback && !canceled) {\n      if (hasConsole && this[kAtomic] !== ATOMIC_MODE_DETACHED) {\n        this[kUnhandledFlag] = true;\n        trackUnhandled(this);\n      }\n    }\n\n    this[kCallbacks] = null;\n    this[kParent] = null;\n    this[kCancelCallbacks] = null;\n    this[kInnerThenable] = null;\n    this[kInternals] = null;\n    this[kTimer] = null;\n  }\n\n  [kResolveTo](value, isRejected) {\n    if (this[kFinalized]) return;\n\n    const settled = this[kState];\n\n    if (isRejected && CanceledError.isCanceledError(value)) {\n      this[kCanceled] = true;\n    } else if (settled) {\n      return;\n    }\n\n    this[kValue] = value;\n    this[kState] = isRejected ? STATE_REJECTED : STATE_FULFILLED;\n\n    if (!settled) {\n      this[kSync] ? this[kFinalize]() : asap(() => this[kFinalize]());\n    }\n  }\n\n  [kResolve](value, isRejected) {\n    const {constructor} = this;\n    let then;\n\n    if (this === value) {\n      return this[kResolveTo](new TypeError(`circular reference to ${value}`), true);\n    }\n\n    if (value && isGenerator(value)) {\n      then = (value = constructor[kResolveGenerator](value, new constructor(noop))).then;\n    } else if (value) {\n      try {\n        then = getThen(value);\n      } catch (err) {\n        return this[kResolveTo](err, true);\n      }\n    }\n\n    if (then && typeof then === 'function') {\n      this[kInnerThenable] = value;\n      this[kDoResolve](then, value);\n    } else {\n      this[kResolveTo](value, isRejected)\n    }\n\n  }\n\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    onRejected = typeof onRejected === 'function' ? onRejected : null;\n\n    this[kUnhandledFlag] && untrackUnhandled(this);\n\n    return new this.constructor(($, $$, promise) => {\n      let invoked;\n\n      const resolver = (value, isRejected) => {\n        if (invoked) return;\n\n        invoked = true;\n\n        const handler = isRejected ? onRejected : onFulfilled;\n\n        try {\n          promise[kResolve](handler ? handler(value, promise) : value, isRejected && !handler);\n        } catch (err) {\n          promise[kResolveTo](err, true);\n        }\n      };\n\n      promise[kParent] = this;\n\n      if (this[kFinalized]) {\n        return this[kSync] ?\n          resolver(this[kValue], this[kState] === STATE_REJECTED) :\n          asap(() => {\n            resolver(this[kValue], this[kState] === STATE_REJECTED)\n          });\n      }\n\n      promise[kCallback] = resolver;\n\n      const callbacks = this[kCallbacks];\n\n      if (callbacks) {\n        typeof callbacks === 'function' ? this[kCallbacks] = [callbacks, resolver] : callbacks.push(resolver);\n      } else {\n        this[kCallbacks] = resolver;\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  finally(callback) {\n    let {constructor} = this;\n\n    return isFunction(callback) ? this.then(\n      (value, scope) => constructor.resolve(callback({value, status: 'fulfilled'}, scope)).then(() => value),\n      (reason, scope) => constructor.resolve(callback({reason, status: 'rejected'}, scope)).then(() => {\n        throw reason;\n      })) : this.then(callback, callback);\n  }\n\n  static allSettled(promises) {\n    return this.all(Array.from(promises).map(promise => promise.then(value => ({\n        status: 'fulfilled', value\n      }), (reason) => ({\n        status: 'rejected', reason\n      }))\n    ))\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosPromise';\n  }\n\n  toString() {\n    const tag = this[kTag];\n    return `${this[Symbol.toStringTag]}${tag ? '#' + tag : ''}{${['pending', 'fulfilled', 'rejected'][this[kState]]}}`\n  }\n\n  static resolve(value, options) {\n    const atomic = options != null ? !!options.atomic : undefined;\n\n    if (value instanceof this && value[kSync] === this[kSync] && value[kAtomic] === atomic) {\n      return value;\n    }\n    const promise = new this(resolve => resolve(value));\n\n    atomic && (promise[kAtomic] = atomic);\n\n    return promise;\n  }\n\n  static reject(reason) {\n    return new this((_, reject) => reject(reason));\n  }\n\n  static all(promises) {\n    return new this((resolve, reject, {onCancel}) => {\n      const {length} = promises = Array.from(promises);\n\n      if (!length) {\n        resolve([]);\n        return;\n      }\n\n      const chains = new Array(length);\n      const results = new Array(length);\n      let cancelRequested;\n      let subscribed;\n      let canceled;\n      let counter = 0;\n\n      const cancel = (reason) => {\n        if (subscribed) {\n          canceled = true;\n          for (let i = 0; i < length; i++) {\n            chains[i].cancel(reason)\n          }\n        } else {\n          cancelRequested = true;\n        }\n      }\n\n      const _reject = (reason) => {\n        reject(reason);\n        !canceled && cancel();\n      };\n\n      for (let i = 0; i < length; i++) {\n        chains[i] = this.resolve(promises[i]).then((value) => {\n          results[i] = value;\n          if (++counter === length) {\n            resolve(value);\n          }\n        }, _reject);\n      }\n\n      subscribed = true;\n\n      cancelRequested ? cancel() : onCancel(cancel);\n    })\n  }\n\n  static race(promises) {\n    return new this((resolve, reject, {onCancel}) => {\n      const {length} = promises = Array.from(promises);\n\n      if (!length) {\n        return;\n      }\n\n      const chains = new Array(length);\n      let cancelRequested;\n      let subscribed;\n      let canceled;\n\n      const cancel = (reason) => {\n        if (subscribed) {\n          canceled = true;\n          for (let i = 0; i < length; i++) {\n            chains[i].cancel(reason)\n          }\n        } else {\n          cancelRequested = true;\n        }\n      }\n\n      const _reject = (reason) => {\n        try {\n          reject(reason);\n        } finally {\n          !canceled && cancel();\n        }\n      };\n\n      for (let i = 0; i < length; i++) {\n        chains[i] = this.resolve(promises[i]).then((value) => {\n          resolve(value);\n          !canceled && cancel();\n        }, _reject);\n      }\n\n      subscribed = true;\n\n      cancelRequested ? cancel() : onCancel(cancel);\n    })\n  }\n\n  static delay(ms, value) {\n    return new this((resolve, _, {onCancel}) => {\n      const timer = setTimeout(resolve, ms, value);\n      onCancel(() => clearTimeout(timer));\n    });\n  }\n\n  static isCanceledError(thing) {\n    return CanceledError.isCanceledError(thing);\n  }\n\n  static isAxiosPromise(thing) {\n    return !!(thing && thing[kPromiseSign]);\n  }\n\n  static [kResolveGenerator](generator, promise) {\n    const onFulfilled = (result) => {\n      try {\n        next(generator.next(result));\n      } catch (e) {\n        promise[kResolveTo](e, true)\n      }\n    }\n\n    const onRejected = (err) => {\n      try {\n        next(generator.throw(err));\n      } catch (e) {\n        promise[kResolveTo](e, true);\n      }\n    }\n\n    const next = (r) => {\n      if (r.done) {\n        return promise[kResolve](r.value);\n      }\n\n      promise[kInnerThenable] = this.resolve(r.value).then(onFulfilled, onRejected);\n    }\n\n    onFulfilled();\n\n    return promise;\n  }\n\n  static _unhandledRejection(unhandledError, p) {\n    console.error(new UnhandledRejectionError(unhandledError, p[kTag] ? `@[${p[kTag]}]` : ''));\n  }\n\n  static promisify(fn, {scopeArg = false, scopeContext = false} = {}) {\n    if (fn && fn[kPromiseSign]) return fn;\n\n    if (!isFunction(fn)) {\n      throw TypeError('value must be a function');\n    }\n\n    let promisified;\n    const context = this;\n\n    if (isGeneratorFunction(fn)) {\n      promisified = function () {\n        return new context((resolve, reject, scope) => {\n          let generatorArgs;\n          if (scopeArg) {\n            generatorArgs = [scope];\n            push.apply(generatorArgs, arguments);\n          } else {\n            generatorArgs = arguments;\n          }\n\n          context[kResolveGenerator](fn.apply(scopeContext || !this || this === global ? scope : this, generatorArgs), scope)\n        });\n      };\n    } else {\n      promisified = function () {\n        try {\n          return context.resolve(fn.apply(this, arguments));\n        } catch (err) {\n          return context.reject(err);\n        }\n      }\n    }\n\n    promisified[kPromiseSign] = true;\n    promisified.original = fn;\n\n    return promisified;\n  }\n\n  static promisifyAll(obj, {reducer, ...options} = {}) {\n    if (Array.isArray(obj)) {\n      return obj.map((value) => isGeneratorFunction(value) ? this.promisify(value, options) : value);\n    } else {\n      const descriptors = Object.getOwnPropertyDescriptors(obj);\n      let ret, value;\n\n      Object.entries(descriptors).forEach(([key, descriptor]) => {\n        if ('value' in descriptor && descriptor.configurable && isGeneratorFunction(value = descriptor.value) &&\n          (!reducer || (ret = reducer.call(obj, key, value)))) {\n          Object.defineProperty(obj, ret || key, {\n            ...descriptor,\n            value: this.promisify(value, options)\n          })\n        }\n      });\n    }\n\n    return obj;\n  }\n}\n\nconst {prototype} = AxiosPromise;\n\nprototype[kSync] = false;\n\nlazyBind(prototype, ['cancel', 'onCancel', 'signal']);\nlazyBind(AxiosPromise,['delay', 'promisify']);\n\ndefineConstants(AxiosPromise, {\n  VERSION,\n  AbortController,\n  AbortSignal,\n  CanceledError,\n  TimeoutError,\n});\n\nexport class AxiosPromiseSync extends AxiosPromise {\n  get [Symbol.toStringTag](){\n    return 'AxiosPromiseSync';\n  }\n}\n\nAxiosPromiseSync.prototype[kSync] = true;\n\nconst bottleneck = (fn, {concurrency = 1, cancelRunning, sync, timeout, taskTimeout, queueTimeout} = {}) => {\n  const queue = [];\n  const running = [];\n  let pending = 0;\n\n  const constructor = sync ? AxiosPromiseSync : AxiosPromise;\n\n  fn = constructor.promisify(fn);\n\n  return function(...args) {\n    let done;\n    let pushed;\n\n    const promise = new constructor((resolve) => {\n      if (pending++ < concurrency) {\n        return resolve();\n      }\n\n      if (cancelRunning && running[0]) {\n        running.shift().cancel('task limit reached');\n      }\n\n      return queue.push(resolve);\n    })\n      .timeout(queueTimeout, 'queue timeout')\n      .then(() => {\n        return constructor.resolve(fn.apply(this, args)).timeout(taskTimeout, 'task timeout')\n      }).finally(() => {\n        done = true;\n        pending--;\n        if (pushed) {\n          const index = running.indexOf(promise);\n          running.splice(index, 1);\n        }\n        queue.length && queue.shift()();\n      });\n\n    if (!done) {\n      pushed = true;\n      running.push(promise);\n    }\n\n    return promise.timeout(timeout);\n  }\n}\n\nexport {\n  isGenerator,\n  isGeneratorFunction,\n  isAsyncFunction,\n  isPlainFunction,\n  isContextDefined,\n  lazyBind,\n  defineConstants,\n  symbols,\n  isAbortSignal,\n  global,\n  isAbortController,\n  setImmediate,\n  asap,\n  AbortSignal,\n  AbortController,\n  EventEmitter,\n  CanceledError,\n  TimeoutError,\n  bottleneck,\n  AxiosPromise as default\n};\n","export const VERSION = \"0.12.2\";"],"names":["hasOwn","hasOwnProperty","obj","prop","call","Object","prototype","toStringTag","Symbol","isFunction","thing","_global","globalThis","global","self","window","_setImmediate","setImmediateSupported","setImmediate","postMessageSupported","postMessage","token","Math","random","callbacks","addEventListener","source","data","length","shift","cb","push","setTimeout","asap","queueMicrotask","process","nextTick","functionTypeTest","constructor","name","isGeneratorFunction","isAsyncFunction","async","isPlainFunction","isContextDefined","context","isAbortSignal","aborted","removeEventListener","utils","lazyBind","props","bindMethods","symbols","forEach","symbol","descriptor","getOwnPropertyDescriptor","value","get","enumerable","defineProperty","this","resolvedValue","boundContext","apply","arguments","set","v","Error","configurable","console","warn","isGenerator","next","throw","defineConstants","descriptors","getOwnPropertyNames","defineProperties","isAbortController","abort","signal","tags","iterator","kInternals","kSignature","for","CanceledError","message","code","super","internal","static","isCanceledError","err","toUpperCase","replace","addSignatureTo","init","TimeoutError","messageOrTimeout","EventEmitter","events","_events","on","event","listener","prepend","listeners","emit","unshift","off","found","i","splice","args","Array","from","slice","l","once","listenerCount","kSignal","kAborted","kAbort","kReason","hasNativeSupport","AbortController","AbortSignal","_AbortSignal","reason","dispatchEvent","type","target","throwIfAborted","toString","_AbortController","UnhandledRejectionError","cause","drop","kPromiseSign","kState","kValue","kCallbacks","kDoResolve","kResolveTo","kResolve","kParent","kInnerThenable","kCanceled","kFinalized","kSync","kCallback","kCancelCallbacks","kFinalize","kUnsubscribe","kResolveGenerator","kAtomic","kCanceledWith","kTag","kTimer","kUnhandledFlag","ATOMIC_MODE_AWAIT","hasConsole","noop","trackUnhandled","untrackUnhandled","trackQueue","timer","handler","p","_unhandledRejection","promise","index","indexOf","clearTimeout","AxiosPromise","executor","timeout","signals","cancel","listen","TypeError","maybeOnCancelSubscriber","onCancel","fn","fnContext","done","e","ms","errorOrMessage","tag","String","atomic","mode","then","chain","resolve","forced","parent","undefined","innerThenable","scope","internals","controller","parentCallbacks","callback","isRejected","canceled","cancelCallbacks","that","invokeCallbacks","hasCallback","settled","getThen","onFulfilled","onRejected","$","$$","invoked","resolver","catch","finally","status","promises","all","map","options","_","reject","chains","results","cancelRequested","subscribed","counter","_reject","generator","result","r","unhandledError","error","scopeArg","scopeContext","promisified","generatorArgs","original","reducer","isArray","promisify","getOwnPropertyDescriptors","ret","entries","key","VERSION","AxiosPromiseSync","concurrency","cancelRunning","sync","taskTimeout","queueTimeout","queue","running","pending","pushed"],"mappings":"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"}
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const{hasOwn:t=(({hasOwnProperty:t})=>(e,n)=>t.call(e,n))(Object.prototype)}=Object,{toStringTag:e}=Symbol,n=t=>"function"==typeof t,r="object"==typeof globalThis&&globalThis||"undefined"!=typeof global&&global||"undefined"!=typeof self&&self||window,s=(o="function"==typeof setImmediate,i=n(r.postMessage),o?setImmediate:i?(l=`axios-promise@${Math.random()}`,c=[],r.addEventListener("message",(({source:t,data:e})=>{t===r&&e===l&&c.length&&c.shift()()}),!1),t=>{c.push(t),r.postMessage(l,"*")}):t=>setTimeout(t));var o,i,l,c;const a="undefined"!=typeof process&&process.nextTick||("undefined"!=typeof queueMicrotask?queueMicrotask:s),u=({constructor:t})=>{const{name:e}=t;return r=>r&&n(r)&&(r.constructor===t||e&&r.constructor.name===e)},h=u((function*(){})),f=u((async()=>{})),p=u((()=>{})),y=t=>null!=t&&t!==r,d=t=>t&&"object"==typeof t&&"boolean"==typeof t.aborted&&n(t.addEventListener)&&n(t.removeEventListener);let m=0;var b={global:r,setImmediate:s,asap:a,isGeneratorFunction:h,isFunction:n,isAsyncFunction:f,isPlainFunction:p,functionTypeTest:u,isContextDefined:y,hasOwn:t,lazyBind:(e,r,{bindMethods:s=!0}={})=>{const o={};return r.forEach((r=>{const i=Symbol(`${r}Lazy`),l=Object.getOwnPropertyDescriptor(e,r),{value:c,get:a,enumerable:u}=l;"value"in l&&!n(c)||(Object.defineProperty(e,r,{get(){if(t.call(this,i))return this[i];const e=a?a.call(this):c,r=this;return this[i]=s&&n(e)?function(){return e.apply(y(this)?this:r,arguments)}:e},set(t){throw Error(`Can not rewrite prop ${r} with ${t}`)},enumerable:u,configurable:!0}),o[r]=i)})),o},isGenerator:t=>t&&"object"==typeof t&&"function"==typeof t.next&&"function"==typeof t.throw&&"Generator"===t[e],defineConstants:(t,e,{configurable:n=!0,enumerable:r=!0}={})=>{const s={};Object.getOwnPropertyNames(e).forEach((t=>{s[t]={value:e[t],enumerable:r,configurable:n}})),Object.defineProperties(t,s)},isAbortSignal:d,isAbortController:t=>t&&"object"==typeof t&&n(t.abort)&&d(t.signal),symbols:(...t)=>({*[Symbol.iterator](){for(;;)yield Symbol(t.shift()||"#"+m++)}})};const g=Symbol("internals"),v=Symbol.for("AxiosPromise.CanceledError");class x extends Error{constructor(t,e){super(t||"This operation was aborted");const n=this.constructor[g];this.name=n.name,this.code=e||n.code}static from(t){return this.isCanceledError(t)?t:new this(t instanceof Error?"AbortError"!==t.name?t.message:"":t)}static isCanceledError(t){return!(!t||!t[v])}static addSignatureTo(t){"function"==typeof t&&(t.prototype[v]=this[g].code)}static rethrow(t,e){if(this.isCanceledError(t)&&(!e||e===t.code))throw t}static init(t,e){this[g]={name:t,code:e||"ERR_"+t.toUpperCase().replace(/ERROR$/,"")},this.addSignatureTo(this)}}x.init("CanceledError");class A extends x{constructor(t,e){super("number"==typeof t?`${t} ms timeout exceeded`:t,e)}}A.init("TimeoutError");class w{constructor(t){this._events=t||{}}on(t,e,n){const r=this._events,s=r[t];return r.newListener&&this.emit("newListener",t,e),s?"function"==typeof s?r[t]=n?[e,s]:[s,e]:n?e.unshift(e):s.push(e):r[t]=e,this}off(t,e){const n=this._events,r=n[t];let s=!1;if(r)if("function"==typeof r)r===e&&(n[t]=null,s=!0);else{let t=r.length;for(;t--;)if(r[t]===e){r.splice(t,1),s=!0;break}}return s&&n.removeListener&&this.emit("removeListener",t,e),s}emit(t){let e=this._events[t];if(!e)return!1;const n=Array.from(arguments).slice(1);if("function"==typeof e)e.apply(null,n);else{const t=e.length;t>1&&(e=e.slice());for(let r=0;r<t;r++)e[r].apply(null,n)}return!0}once(t,e,n){const r=()=>{this.off(t,r),e.apply(null,arguments)};return this.on(t,r,n)}listenerCount(t){const e=this._events[t];return e?"function"==typeof e?1:e.length:0}}const{prototype:E}=w;E.addEventListener=E.on,E.removeEventListener=E.off;const[S,C,T,j]=b.symbols("signal","aborted","abort","reason"),O="function"==typeof AbortController&&"function"==typeof AbortSignal&&"reason"in(new AbortController).signal,P=O?AbortSignal:class extends w{constructor(){super(),this[C]=!1}get aborted(){return this[C]}get reason(){return this[j]}[T](t){this[C]||(this[C]=!0,this[j]=t,this.dispatchEvent("abort"))}dispatchEvent(t){const e={type:t,target:this};let n;"function"==typeof(n=this["on"+t])&&n.call(this,e),this.emit(t,e)}throwIfAborted(){if(this[C])throw this[j]}get[Symbol.toStringTag](){return"AbortSignal"}toString(){return"[object AbortSignal]"}},F=O?AbortController:class{constructor(){this[S]=null}get signal(){return this[S]||(this[S]=new P)}abort(t){this.signal[T](t)}get[Symbol.toStringTag](){return"AbortController"}toString(){return"[object AbortController]"}};class L extends Error{constructor(t,e){super((e?e+": ":"")+(t.message||t),{cause:t}),this.name="UnhandledRejectionError"}}const{isGenerator:$,isFunction:k,isGeneratorFunction:R,isAsyncFunction:_,isPlainFunction:G,isContextDefined:I,lazyBind:M,defineConstants:z,symbols:D,isAbortSignal:q,global:B,setImmediate:N,isAbortController:U,asap:V,drop:W}=b,H=Symbol.for("AxiosPromise"),[J,K,Q,X,Y,Z,tt,et,nt,rt,st,ot,it,lt,ct,at,ut,ht,ft,pt,yt,dt]=D("state","value","callbacks","doResolve","resolveTo","resolve","parent","innerThenable","canceled","finalized","sync","callback","cancelCallbacks","internals","finalize","unsubscribe","resolveGenerator","atomic","canceledWith","tag","timer","unhandledFlag"),mt=!1,{push:bt}=Array.prototype,gt="undefined"!=typeof console&&console,vt=()=>{},[xt,At]=((t,e)=>{let n;const r=()=>{n=0;let e,r=t.length;for(let n=0;n<r;n++)(e=t[n]).constructor._unhandledRejection(e[K],e);t=[]};return[s=>{t.push(s),e++,n||(n=setTimeout(r))},r=>{const s=t.indexOf(r);s<0||(--e?t.splice(s,1):(n&&clearTimeout(n),n=0,t=[]))}]})([],0);class wt{constructor(t,{signal:e,timeout:n}={}){if(this[J]=0,this[Q]=null,this[lt]={signals:null},e){if(e.aborted)return this.cancel(e.reason),this;this.listen(e)}let r;if(n&&this.timeout(n),t!==vt){if("function"!=(r=typeof t))return this[Y](new TypeError(`Promise resolver ${r} is not a function`)),this;const e=this[X](t);e&&k(e)&&this.onCancel(e)}}[X](t,e){let n=!1;try{return t.call(e,(t=>{n||(n=!0,this[Z](t,!1))}),(t=>{n||(n=!0,this[Y](t,!0))}),this)}catch(t){if(n)return;n=!0,this[Y](t,!0)}}timeout(t,e){return this[J]||(this[yt]&&(clearTimeout(this[yt]),this[yt]=0),t>0&&(this[yt]=setTimeout((()=>{this[yt]=0,this.cancel(A.from(e||t))}),t))),this}tag(t){return arguments.length?(this[pt]=String(t),this):this[pt]||""}atomic(t=false){const e=this.then();return e[ht]=this[ht]=!!t,e}static atomic(t,e=false){return this.resolve(t,{atomic:e})}cancel(t,e){if(this[rt])return!1;let n,r=this,s=r[ht];for(;void 0===s&&(n=r[tt])&&!n[rt]&&(e||"function"==typeof n[Q]||n[Q].length<=1);)s=n[ht],r=n;if(t=x.from(t),s===mt)return r[ft]=t,!0;const o=r[et];return o&&"function"==typeof o.cancel&&o.cancel(t)||r[nt]||(t.scope=r,r[Y](t,!0)),!0}listen(t){if(null!=t&&!this[rt]){if(!q(t))throw TypeError("expected AbortSignal object");const e=this[lt];e.signals?e.signals.push(t):e.signals=[t],t.addEventListener("abort",(()=>this.cancel(t.reason)))}return this}onCancel(t){this[it]?this[it].push(t):this[it]=[t]}get signal(){return(this[lt].controller=new F).signal}[at](t){const e=this[Q],n=t[ot];if("function"==typeof e&&e===n)this[Q]=null;else{let t=e.length;for(;t--;)if(e[t]===n)return e.splice(t,1)}}[ct](){this[rt]=!0;let t=this[K],e=2===this[J],n=this[nt];const r=this[lt],{signals:s,controller:o}=r,i=this[tt];if(!e&&this[ft]&&(n=!0,e=!0,t=this[ft]),i&&!i[rt]&&i[at](this),this[yt]&&clearTimeout(this[yt]),s){let t=s.length;for(;t--;)s[t].removeEventListener("abort",this.cancel)}if(n){const e=this[it];e&&((t,e,n)=>{if(!t)return!1;if("function"==typeof t)return t.apply(n,e),!0;{const{length:r}=t;for(let s=0;s<r;s++)t[s].apply(n,e)}})(e,[t]),o&&o.abort(t)}const l=this[Q];let c;if(l)if("function"==typeof l)c=!0,l(t,e);else{const{length:n}=l;c=n;for(let r=0;r<n;r++)l[r](t,e)}!e||c||n||gt&&true!==this[ht]&&(this[dt]=!0,xt(this)),this[Q]=null,this[tt]=null,this[it]=null,this[et]=null,this[lt]=null,this[yt]=null}[Y](t,e){if(this[rt])return;const n=this[J];if(e&&x.isCanceledError(t))this[nt]=!0;else if(n)return;this[K]=t,this[J]=e?2:1,n||(this[st]?this[ct]():V((()=>this[ct]())))}[Z](t,e){const{constructor:n}=this;let r;if(this===t)return this[Y](new TypeError(`circular reference to ${t}`),!0);if(t&&$(t))r=(t=n[ut](t,new n(vt))).then;else if(t)try{r=(t=>{let e,n;if(("object"==(e=typeof t)||"function"===e)&&"function"==typeof(n=t.then))return n})(t)}catch(t){return this[Y](t,!0)}r&&"function"==typeof r?(this[et]=t,this[X](r,t)):this[Y](t,e)}then(t,e){return t="function"==typeof t?t:null,e="function"==typeof e?e:null,this[dt]&&At(this),new this.constructor(((n,r,s)=>{let o;const i=(n,r)=>{if(o)return;o=!0;const i=r?e:t;try{s[Z](i?i(n,s):n,r&&!i)}catch(t){s[Y](t,!0)}};if(s[tt]=this,this[rt])return this[st]?i(this[K],2===this[J]):V((()=>{i(this[K],2===this[J])}));s[ot]=i;const l=this[Q];l?"function"==typeof l?this[Q]=[l,i]:l.push(i):this[Q]=i}))}catch(t){return this.then(null,t)}finally(t){let{constructor:e}=this;return k(t)?this.then(((n,r)=>e.resolve(t({value:n,status:"fulfilled"},r)).then((()=>n))),((n,r)=>e.resolve(t({reason:n,status:"rejected"},r)).then((()=>{throw n})))):this.then(t,t)}static allSettled(t){return this.all(Array.from(t).map((t=>t.then((t=>({status:"fulfilled",value:t})),(t=>({status:"rejected",reason:t}))))))}get[Symbol.toStringTag](){return"AxiosPromise"}toString(){const t=this[pt];return`${this[Symbol.toStringTag]}${t?"#"+t:""}{${["pending","fulfilled","rejected"][this[J]]}}`}static resolve(t,e){const n=null!=e?!!e.atomic:void 0;if(t instanceof this&&t[st]===this[st]&&t[ht]===n)return t;const r=new this((e=>e(t)));return n&&(r[ht]=n),r}static reject(t){return new this(((e,n)=>n(t)))}static all(t){return new this(((e,n,{onCancel:r})=>{const{length:s}=t=Array.from(t);if(!s)return void e([]);const o=new Array(s),i=new Array(s);let l,c,a,u=0;const h=t=>{if(c){a=!0;for(let e=0;e<s;e++)o[e].cancel(t)}else l=!0},f=t=>{n(t),!a&&h()};for(let n=0;n<s;n++)o[n]=this.resolve(t[n]).then((t=>{i[n]=t,++u===s&&e(t)}),f);c=!0,l?h():r(h)}))}static race(t){return new this(((e,n,{onCancel:r})=>{const{length:s}=t=Array.from(t);if(!s)return;const o=new Array(s);let i,l,c;const a=t=>{if(l){c=!0;for(let e=0;e<s;e++)o[e].cancel(t)}else i=!0},u=t=>{try{n(t)}finally{!c&&a()}};for(let n=0;n<s;n++)o[n]=this.resolve(t[n]).then((t=>{e(t),!c&&a()}),u);l=!0,i?a():r(a)}))}static delay(t,e){return new this(((n,r,{onCancel:s})=>{const o=setTimeout(n,t,e);s((()=>clearTimeout(o)))}))}static isCanceledError(t){return x.isCanceledError(t)}static isAxiosPromise(t){return!(!t||!t[H])}static[ut](t,e){const n=n=>{try{s(t.next(n))}catch(t){e[Y](t,!0)}},r=n=>{try{s(t.throw(n))}catch(t){e[Y](t,!0)}},s=t=>{if(t.done)return e[Z](t.value);e[et]=this.resolve(t.value).then(n,r)};return n(),e}static _unhandledRejection(t,e){console.error(new L(t,e[pt]?`@[${e[pt]}]`:""))}static promisify(t,{scopeArg:e=!1,scopeContext:n=!1}={}){if(t&&t[H])return t;if(!k(t))throw TypeError("value must be a function");let r;const s=this;return r=R(t)?function(){return new s(((r,o,i)=>{let l;e?(l=[i],bt.apply(l,arguments)):l=arguments,s[ut](t.apply(n||!this||this===B?i:this,l),i)}))}:function(){try{return s.resolve(t.apply(this,arguments))}catch(t){return s.reject(t)}},r[H]=!0,r.original=t,r}static promisifyAll(t,{reducer:e,...n}={}){if(Array.isArray(t))return t.map((t=>R(t)?this.promisify(t,n):t));{const r=Object.getOwnPropertyDescriptors(t);let s,o;Object.entries(r).forEach((([r,i])=>{"value"in i&&i.configurable&&R(o=i.value)&&(!e||(s=e.call(t,r,o)))&&Object.defineProperty(t,s||r,{...i,value:this.promisify(o,n)})}))}return t}}const{prototype:Et}=wt;Et[st]=!1,M(Et,["cancel","onCancel","signal"]),M(wt,["delay","promisify"]),z(wt,{VERSION:"0.12.3",AbortController:F,AbortSignal:P,CanceledError:x,TimeoutError:A});class St extends wt{get[Symbol.toStringTag](){return"AxiosPromiseSync"}}St.prototype[st]=!0;exports.AbortController=F,exports.AbortSignal=P,exports.AxiosPromise=wt,exports.AxiosPromiseSync=St,exports.CanceledError=x,exports.EventEmitter=w,exports.TimeoutError=A,exports.asap=V,exports.bottleneck=(t,{concurrency:e=1,cancelRunning:n,sync:r,timeout:s,taskTimeout:o,queueTimeout:i}={})=>{const l=[],c=[];let a=0;const u=r?St:wt;return t=u.promisify(t),function(...r){let h,f;const p=new u((t=>a++<e?t():(n&&c[0]&&c.shift().cancel("task limit reached"),l.push(t)))).timeout(i,"queue timeout").then((()=>u.resolve(t.apply(this,r)).timeout(o,"task timeout"))).finally((()=>{if(h=!0,a--,f){const t=c.indexOf(p);c.splice(t,1)}l.length&&l.shift()()}));return h||(f=!0,c.push(p)),p.timeout(s)}},exports.default=wt,exports.defineConstants=z,exports.global=B,exports.isAbortController=U,exports.isAbortSignal=q,exports.isAsyncFunction=_,exports.isContextDefined=I,exports.isGenerator=$,exports.isGeneratorFunction=R,exports.isPlainFunction=G,exports.lazyBind=M,exports.setImmediate=N,exports.symbols=D;
//# sourceMappingURL=axios-promise.min.js.map

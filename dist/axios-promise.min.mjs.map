{"version":3,"file":"axios-promise.min.mjs","sources":["../lib/utils.js","../lib/CanceledError.js","../lib/TimeoutError.js","../lib/EventEmitter.js","../lib/AbortController.js","../lib/index.js"],"sourcesContent":["const {\r\n  hasOwn = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype)\r\n} = Object;\r\n\r\nconst isFunction = (thing) => typeof thing === 'function';\r\n\r\nconst _global = typeof globalThis === 'object' && globalThis ||\r\n  (typeof global !== \"undefined\" && global) ||\r\n  (typeof self !== \"undefined\" && self) || window\r\n\r\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\r\n  if (setImmediateSupported) {\r\n    return setImmediate;\r\n  }\r\n\r\n  return postMessageSupported ? ((token, callbacks) => {\r\n    _global.addEventListener(\"message\", ({source, data}) => {\r\n      if (source === _global && data === token) {\r\n        callbacks.length && callbacks.shift()();\r\n      }\r\n    }, false);\r\n\r\n    return (cb) => {\r\n      callbacks.push(cb);\r\n      _global.postMessage(token, \"*\");\r\n    }\r\n  })(`axios-promise@${Math.random()}`, []) : (cb) => setTimeout(cb);\r\n})(\r\n  typeof setImmediate === 'function',\r\n  isFunction(_global.postMessage)\r\n);\r\n\r\nconst asap = typeof queueMicrotask !== 'undefined' ?\r\n  queueMicrotask : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\r\n\r\nconst functionTypeTest = ({constructor}) => (thing) => thing && isFunction(thing) && thing.constructor === constructor;\r\n\r\nconst isGeneratorFunction = functionTypeTest(function* () {});\r\n\r\nconst isAsyncFunction = functionTypeTest(async () => {});\r\n\r\nconst isPlainFunction = functionTypeTest(() => {});\r\n\r\nconst isGenerator = (obj) => obj && isFunction(obj.next) && isFunction(obj.throw);\r\n\r\nconst isContextDefined = (context) => context != null && context !== _global;\r\n\r\nconst lazyBind = (obj, props, {bindMethods = true} = {}) => {\r\n  const symbols = {};\r\n\r\n  props.forEach(prop => {\r\n    const symbol = Symbol(`${prop}Lazy`);\r\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\r\n    const {value, get, enumerable} = descriptor;\r\n\r\n    if('value' in descriptor && !isFunction(value)) {\r\n      console.warn('skip', prop);\r\n      return;\r\n    }\r\n\r\n    Object.defineProperty(obj, prop, {\r\n      get() {\r\n        if (hasOwn.call(this, symbol)) {\r\n          return this[symbol];\r\n        }\r\n\r\n        const resolvedValue = get ? get.call(this) : value;\r\n\r\n        const boundContext = this;\r\n\r\n        return this[symbol] = bindMethods && isFunction(resolvedValue) ? function () {\r\n          return resolvedValue.apply(isContextDefined(this) ? this : boundContext, arguments);\r\n        } : resolvedValue;\r\n      },\r\n\r\n      set(v) {\r\n        throw Error(`Can not rewrite prop ${prop} with ${v}`);\r\n      },\r\n\r\n      enumerable,\r\n      configurable: true\r\n    });\r\n\r\n    symbols[prop] = symbol;\r\n  });\r\n\r\n  return symbols;\r\n}\r\n\r\nconst defineConstants = (obj, props, {configurable = true, enumerable = true} = {}) => {\r\n  const descriptors = {};\r\n\r\n  Object.getOwnPropertyNames(props).forEach((prop) => {\r\n    descriptors[prop] = {value: props[prop], enumerable, configurable}\r\n  })\r\n\r\n  Object.defineProperties(obj, descriptors);\r\n};\r\n\r\nconst isAbortSignal = (thing) => {\r\n  return thing &&\r\n    typeof thing === 'object' &&\r\n    typeof thing.aborted === 'boolean' &&\r\n    isFunction(thing.addEventListener) &&\r\n    isFunction(thing.removeEventListener);\r\n}\r\n\r\nconst isAbortController = (thing) => {\r\n  return thing && typeof thing === 'object' && isFunction(thing.abort) && isAbortSignal(thing.signal);\r\n};\r\n\r\nconst symbols = (...tags) => ({\r\n  * [Symbol.iterator]() {\r\n    while (true) {\r\n      yield Symbol(tags.shift() || '');\r\n    }\r\n  }\r\n})\r\n\r\nexport default {\r\n  global: _global,\r\n  setImmediate: _setImmediate,\r\n  asap,\r\n  isGeneratorFunction,\r\n  isAsyncFunction,\r\n  isPlainFunction,\r\n  functionTypeTest,\r\n  isContextDefined,\r\n  hasOwn,\r\n  lazyBind,\r\n  isGenerator,\r\n  defineConstants,\r\n  isAbortSignal,\r\n  isAbortController,\r\n  symbols\r\n}\r\n","const kInternals = Symbol('internals');\r\nconst kSignature = Symbol.for(`AxiosPromise.CanceledError`);\r\n\r\nexport class CanceledError extends Error {\r\n  constructor(message) {\r\n    super(message || 'canceled');\r\n    const {name, code} = this.constructor[kInternals];\r\n    this.name = name;\r\n    this.code = code;\r\n  }\r\n\r\n  static from(thing) {\r\n    return this.isCanceledError(thing) ? thing : new this(thing instanceof Error ? thing.message : '');\r\n  }\r\n\r\n  static isCanceledError(err) {\r\n    return !!(err && err[kSignature]);\r\n  }\r\n\r\n  static addSignature(constructor) {\r\n    typeof constructor === 'function' && (constructor.prototype[kSignature] = this[kInternals].code);\r\n  }\r\n\r\n  static rethrow(err, code) {\r\n    if (this.isCanceledError(err) && (!code || code === err.code)) {\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  static init(name, code) {\r\n    this[kInternals] = {\r\n      name,\r\n      code: code || 'ERR_' + name.toUpperCase().replace(/ERROR$/, '')\r\n    }\r\n\r\n    this.addSignature(this);\r\n  }\r\n}\r\n\r\nCanceledError.init('CanceledError');\r\n","import {CanceledError} from './CanceledError.js';\r\n\r\nexport class TimeoutError extends CanceledError {\r\n  constructor(messageOrTimeout) {\r\n    super(typeof messageOrTimeout === 'number' ? `${messageOrTimeout} ms timeout exceeded` : messageOrTimeout);\r\n  }\r\n}\r\n\r\nTimeoutError.init('TimeoutError');\r\n\r\n","export default class EventEmitter {\r\n  constructor(events) {\r\n    this._events = events || {};\r\n  }\r\n\r\n  on(event, listener, prepend) {\r\n    const events = this._events\r\n    const listeners = events[event];\r\n\r\n    events['newListener'] && this.emit('newListener', event, listener);\r\n\r\n    if (!listeners) {\r\n      events[event] = listener\r\n    } else if (typeof listeners === 'function') {\r\n      events[event] = prepend ? [listener, listeners] : [listeners, listener];\r\n    } else {\r\n      prepend ? listener.unshift(listener) : listeners.push(listener);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  off(event, listener) {\r\n    const events = this._events\r\n    const listeners = events[event];\r\n    let found = false;\r\n\r\n    if (listeners) {\r\n      if (typeof listeners === 'function') {\r\n        if (listeners === listener) {\r\n          events[event] = null;\r\n          found = true;\r\n        }\r\n      } else {\r\n        let i = listeners.length;\r\n        while (i--) {\r\n          if (listeners[i] === listener) {\r\n            listeners.splice(i, 1);\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    found && events['removeListener'] && this.emit('removeListener', event, listener);\r\n\r\n    return found;\r\n  }\r\n\r\n  emit(event) {\r\n    const listeners = this._events[event];\r\n    if (!listeners) return false;\r\n\r\n    const args = Array.from(arguments).slice(1);\r\n\r\n    if (typeof listeners === 'function') {\r\n      listeners.apply(null, args);\r\n    } else {\r\n      const l = listeners.length;\r\n      for (let i = 0; i < l; i++) {\r\n        listeners.apply(null, args);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  once(event, listener, prepend) {\r\n    const once = () => {\r\n      this.off(event, once);\r\n      listener.apply(null, arguments);\r\n    };\r\n\r\n    return this.on(event, once, prepend);\r\n  }\r\n\r\n  listenerCount(event) {\r\n    const listeners = this._events[event];\r\n    return listeners ? (typeof listeners === 'function' ? 1 : listeners.length) : 0;\r\n  }\r\n}\r\n\r\nconst {prototype} = EventEmitter;\r\n\r\nprototype.addEventListener = prototype.on;\r\nprototype.removeEventListener = prototype.off;\r\n","import utils from './utils.js';\r\nimport EventEmitter from \"./EventEmitter.js\";\r\n\r\nconst [kSignal, kAborted, kAbort, kEvents] = utils.symbols('signal', 'aborted', 'abort', 'events');\r\n\r\nconst hasNativeSupport = typeof AbortController === 'function' && typeof AbortSignal === 'function';\r\n\r\nconst _AbortSignal = hasNativeSupport ? AbortSignal : class AbortSignal extends EventEmitter{\r\n  constructor() {\r\n    super();\r\n    this[kAborted] = false;\r\n  }\r\n\r\n  get aborted() {\r\n    return this[kAborted];\r\n  }\r\n\r\n  [kAbort]() {\r\n    if (!this[kAborted]) {\r\n      this[kAborted] = true;\r\n      this.dispatchEvent('abort');\r\n    }\r\n  }\r\n\r\n  dispatchEvent(type) {\r\n    const event = {\r\n      type,\r\n      target: this\r\n    };\r\n\r\n    let listener;\r\n\r\n    typeof (listener = this['on' + type]) === 'function' && listener.call(this, event);\r\n\r\n    this[kEvents].emit(type, event)\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'AbortSignal'\r\n  }\r\n\r\n  toString() {\r\n    return '[object AbortSignal]'\r\n  }\r\n}\r\n\r\nconst _AbortController = hasNativeSupport ? AbortController : class AbortControllerPolyfill {\r\n  constructor() {\r\n    this[kSignal] = null;\r\n  }\r\n\r\n  get signal() {\r\n    return this[kSignal] || (this[kSignal] = new _AbortSignal());\r\n  }\r\n\r\n  abort(reason) {\r\n    this.signal[kAbort](reason);\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'AbortController'\r\n  }\r\n\r\n  toString() {\r\n    return '[object AbortController]'\r\n  }\r\n}\r\n\r\nexport {\r\n  _AbortController as AbortController,\r\n  _AbortSignal as AbortSignal,\r\n}\r\n","import utils from './utils.js';\r\nimport {CanceledError} from \"./CanceledError.js\";\r\nimport {TimeoutError} from \"./TimeoutError.js\";\r\nimport {AbortController, AbortSignal} from \"./AbortController.js\"\r\nimport EventEmitter from \"./EventEmitter.js\";\r\n\r\nconst {isGenerator, isGeneratorFunction, isFunction, lazyBind, asap, defineConstants, symbols, isAbortSignal} = utils;\r\n\r\nconst kPromiseSign = Symbol.for('AxiosPromise');\r\n\r\nconst [\r\n  kState,\r\n  kValue,\r\n  kCallbacks,\r\n  kDoResolve,\r\n  kResolveTo,\r\n  kResolve,\r\n  kParent,\r\n  kInnerThenable,\r\n  kCanceled,\r\n  kFinalized,\r\n  kSync,\r\n  kCallback,\r\n  kCancelCallbacks,\r\n  kInternals,\r\n  kFinalize,\r\n  kUnsubscribe,\r\n  kResolveGenerator,\r\n  kAtomic,\r\n  kCanceledWith,\r\n  kUncaught,\r\n  kTag,\r\n  kUnhandledRejection,\r\n  kTimer\r\n] = symbols(\r\n  'state',\r\n  'value',\r\n  'callbacks',\r\n  'doResolve',\r\n  'resolveTo',\r\n  'resolve',\r\n  'parent',\r\n  'innerThenable',\r\n  'canceled',\r\n  'finalized',\r\n  'sync',\r\n  'callback',\r\n  'cancelCallbacks',\r\n  'internals',\r\n  'finalize',\r\n  'unsubscribe',\r\n  'resolveGenerator',\r\n  'atomic',\r\n  'canceledWith',\r\n  'uncaught',\r\n  'tag',\r\n  'unhandledRejection',\r\n  'timer'\r\n);\r\n\r\nconst STATE_PENDING = 0;\r\nconst STATE_FULFILLED = 1;\r\nconst STATE_REJECTED = 2;\r\n\r\nconst ATOMIC_MODE_DISABLED = 0;\r\nconst ATOMIC_MODE_AWAIT = 1;\r\nconst ATOMIC_MODE_DETACHED = 2;\r\n\r\nconst {push} = Array.prototype;\r\n\r\nconst hasConsole = typeof console !== 'undefined' && console;\r\n\r\nconst noop = () => {};\r\n\r\nconst getMethod = (obj, name) => {\r\n  let type;\r\n  let then;\r\n\r\n  if(((type = typeof obj) === 'object' || type === 'function') && typeof (then = obj[name]) === 'function') {\r\n    return then;\r\n  }\r\n}\r\n\r\nconst invokeCallbacks = (callbacks, args, that) => {\r\n  if(!callbacks) return false;\r\n\r\n  if (typeof callbacks === 'function') {\r\n    callbacks.apply(that, args);\r\n    return true;\r\n  } else {\r\n    const {length} = callbacks;\r\n    for (let i = 0; i < length; i++) {\r\n      callbacks[i].apply(that, args);\r\n    }\r\n    return !!length;\r\n  }\r\n}\r\n\r\nconst appendCallback = (store, key, callback) => {\r\n  const existingCallbacks = store[key];\r\n  if (existingCallbacks) {\r\n    if (typeof existingCallbacks !== 'function') {\r\n      store[key] = [existingCallbacks, callback];\r\n    } else {\r\n      existingCallbacks.push(callback);\r\n    }\r\n  } else {\r\n    store[key] = callback;\r\n  }\r\n}\r\n\r\nexport class AxiosPromise{\r\n  constructor(executor, {signal, timeout} = {}) {\r\n    this[kState] = STATE_PENDING;\r\n    this[kCallbacks] = null;\r\n    this[kInternals] = {\r\n      signals: null\r\n    }\r\n\r\n    if(signal) {\r\n      if(signal.aborted) {\r\n        this.cancel();\r\n        return this;\r\n      }\r\n\r\n      this.listen(signal);\r\n    }\r\n\r\n    timeout && this.timeout(timeout);\r\n\r\n    let type;\r\n\r\n    if(executor !== noop) {\r\n      if ((type = typeof executor) !== 'function') {\r\n        this[kResolveTo](new TypeError(`Promise resolver ${type} is not a function`));\r\n        return this;\r\n      }\r\n\r\n      this[kDoResolve](executor);\r\n    }\r\n  }\r\n\r\n  [kDoResolve](fn, fnContext) {\r\n    let done = false;\r\n\r\n    try {\r\n      return fn.call(fnContext,\r\n        (value) => {\r\n          if (done) return;\r\n          done = true;\r\n          this[kResolve](value, false);\r\n        }, (reason) => {\r\n          if (done) return;\r\n          done = true;\r\n          this[kResolveTo](reason, true);\r\n        }, this);\r\n    } catch (e) {\r\n      if (done) return;\r\n      done = true;\r\n      this[kResolveTo](e, true);\r\n    }\r\n  }\r\n\r\n  timeout(ms) {\r\n    if (!this[kState]) {\r\n      if (this[kTimer]) {\r\n        clearTimeout(this[kTimer]);\r\n        this[kTimer] = 0;\r\n      }\r\n\r\n      if (ms > 0) {\r\n        this[kTimer] = setTimeout(() => {\r\n          this[kTimer] = 0;\r\n          this.cancel(new TimeoutError(ms))\r\n        }, ms);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  tag(tag) {\r\n    if (!arguments.length) {\r\n      return this[kTag] || '';\r\n    }\r\n    this[kTag] = String(tag);\r\n    return this;\r\n  }\r\n\r\n  atomic(mode = ATOMIC_MODE_AWAIT) {\r\n    const promise = this.then();\r\n\r\n    promise[kAtomic] = (this[kAtomic] = mode);\r\n\r\n    return promise;\r\n  }\r\n\r\n  static atomic(chain, mode = ATOMIC_MODE_AWAIT) {\r\n    return this.resolve(chain, {atomic: mode})\r\n  }\r\n\r\n  uncaught(handler = noop) {\r\n    const appendedHandler = this[kUncaught];\r\n    this[kUncaught] = appendedHandler && appendedHandler !== noop ? [appendedHandler, handler] : handler;\r\n    return this;\r\n  }\r\n\r\n  cancel(reason, forced) {\r\n    if (this[kFinalized]) return false;\r\n\r\n    let target = this;\r\n    let parent;\r\n    let atomic = target[kAtomic];\r\n\r\n    while (!atomic && (parent = target[kParent]) && !parent[kFinalized] && (forced || typeof parent[kCallbacks] === 'function' || parent[kCallbacks].length <= 1)) {\r\n      atomic = parent[kAtomic]\r\n      target = parent;\r\n    }\r\n\r\n    reason = CanceledError.from(reason);\r\n\r\n    if (atomic === ATOMIC_MODE_AWAIT) {\r\n      target[kCanceledWith] = reason;\r\n      return true;\r\n    }\r\n\r\n    const innerThenable = target[kInnerThenable];\r\n\r\n    if (!(innerThenable && typeof innerThenable.cancel === 'function' && innerThenable.cancel(reason)) && !target[kCanceled]) {\r\n      reason.scope = target;\r\n      target[kResolveTo](reason, true);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  listen(signal) {\r\n    if (!isAbortSignal(signal)) {\r\n      throw TypeError('expected AbortSignal object');\r\n    }\r\n\r\n    const internals = this[kInternals];\r\n\r\n    if (internals.signals) {\r\n      internals.signals.push(signal);\r\n    } else {\r\n      internals.signals = [signal];\r\n    }\r\n\r\n    signal.addEventListener('abort', () => this.cancel());\r\n\r\n    return this;\r\n  }\r\n\r\n  onCancel(listener) {\r\n    this[kCancelCallbacks] ? this[kCancelCallbacks].push(listener) : this[kCancelCallbacks] = [listener];\r\n  }\r\n\r\n  get signal(){\r\n    return (this[kInternals].controller = new AbortController()).signal;\r\n  }\r\n\r\n  [kUnsubscribe](chain) {\r\n    const parentCallbacks = this[kCallbacks];\r\n    const callback = chain[kCallback];\r\n    // TODO: parentCallbacks === callback probably redundant\r\n    if(typeof parentCallbacks === 'function' && parentCallbacks === callback) {\r\n      this[kCallbacks] = null;\r\n    } else {\r\n      let i = parentCallbacks.length;\r\n      while (i--) {\r\n        if (parentCallbacks[i] === callback) {\r\n          return parentCallbacks.splice(i, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  [kFinalize](){\r\n    this[kFinalized] = true;\r\n\r\n    let value = this[kValue];\r\n    let isRejected = this[kState] === STATE_REJECTED;\r\n    let canceled = this[kCanceled];\r\n    const internals = this[kInternals];\r\n    const {signals, controller} = internals;\r\n    const parent = this[kParent];\r\n\r\n    if (!isRejected && this[kCanceledWith]) {\r\n      canceled = true;\r\n      isRejected = true;\r\n      value = this[kCanceledWith];\r\n    }\r\n\r\n    if (parent && !parent[kFinalized]) { // Premature resolving - unsubscribe from parent chain\r\n      parent[kUnsubscribe](this);\r\n    }\r\n\r\n    this[kTimer] && clearTimeout(this[kTimer]);\r\n\r\n    if (signals) {\r\n      let i = signals.length;\r\n      while (i--) {\r\n        signals[i].removeEventListener('abort', this.cancel);\r\n      }\r\n    }\r\n\r\n    if(canceled){\r\n      const cancelCallbacks = this[kCancelCallbacks];\r\n\r\n      if (cancelCallbacks) {\r\n        invokeCallbacks(cancelCallbacks, [value]);\r\n      }\r\n\r\n      controller && controller.abort();\r\n    }\r\n\r\n    const callbacks = this[kCallbacks];\r\n\r\n    let hasCallback;\r\n\r\n    if(callbacks) {\r\n      if (typeof callbacks === 'function') {\r\n        hasCallback = true;\r\n        callbacks(value, isRejected);\r\n      } else {\r\n        const {length} = callbacks;\r\n        hasCallback = length;\r\n        for (let i = 0; i < length; i++) {\r\n          callbacks[i](value, isRejected);\r\n        }\r\n      }\r\n    }\r\n\r\n    if(isRejected && !hasCallback && !canceled) {\r\n      const uncaughtCallbacks = this[kUncaught];\r\n      if (uncaughtCallbacks) {\r\n        uncaughtCallbacks !== noop && invokeCallbacks(uncaughtCallbacks, [value])\r\n      } else if (hasConsole && this[kAtomic] !== ATOMIC_MODE_DETACHED) {\r\n        this.constructor[kUnhandledRejection](value);\r\n      }\r\n    }\r\n\r\n    this[kCallbacks] = null;\r\n    this[kParent] = null;\r\n    this[kCancelCallbacks] = null;\r\n    this[kInnerThenable] = null;\r\n    this[kInternals] = null;\r\n    this[kUncaught] = null;\r\n    this[kTimer] = null;\r\n  }\r\n\r\n  [kResolveTo](value, isRejected) {\r\n    if (this[kFinalized]) return;\r\n\r\n    const settled = this[kState];\r\n\r\n    if (isRejected && CanceledError.isCanceledError(value)) {\r\n      this[kCanceled] = true;\r\n    } else if (settled) {\r\n      return;\r\n    }\r\n\r\n    this[kValue] = value;\r\n\r\n    if (!settled) {\r\n      this[kState] = isRejected ? STATE_REJECTED : STATE_FULFILLED;\r\n\r\n      this[kSync] ? this[kFinalize]() : asap(() => this[kFinalize]());\r\n    }\r\n  }\r\n\r\n  [kResolve](value, isRejected) {\r\n    const {constructor} = this;\r\n    let then;\r\n\r\n    if (this === value) {\r\n      return this[kResolveTo](new TypeError(`circular reference to ${value}`), true);\r\n    }\r\n\r\n    if (value && isGenerator(value)) {\r\n      then = (value = constructor[kResolveGenerator](value, new constructor(noop))).then;\r\n    } else if (value) {\r\n      try {\r\n        then = getMethod(value, 'then');\r\n      } catch (err) {\r\n        return this[kResolveTo](err, true);\r\n      }\r\n    }\r\n\r\n    if (then && typeof then === 'function') {\r\n      this[kInnerThenable] = value;\r\n      this[kDoResolve](then, value);\r\n    } else {\r\n      this[kResolveTo](value, isRejected)\r\n    }\r\n\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\r\n    onRejected = typeof onRejected === 'function' ? onRejected : null;\r\n\r\n    return new this.constructor(($, $$, promise) => {\r\n      let invoked;\r\n\r\n      const resolver = (value, isRejected) => {\r\n        if (invoked) return;\r\n\r\n        invoked = true;\r\n\r\n        const handler = isRejected ? onRejected : onFulfilled;\r\n\r\n        try {\r\n          promise[kResolve](handler ? handler(value, promise) : value, isRejected && !handler);\r\n        } catch (err) {\r\n          promise[kResolveTo](err, true);\r\n        }\r\n      };\r\n\r\n      promise[kParent] = this;\r\n\r\n      if (this[kFinalized]) {\r\n        return this[kSync] ?\r\n          resolver(this[kValue], this[kState] === STATE_REJECTED) :\r\n          asap(() => {\r\n            resolver(this[kValue], this[kState] === STATE_REJECTED)\r\n          });\r\n      }\r\n\r\n      promise[kCallback] = resolver;\r\n\r\n      const callbacks = this[kCallbacks];\r\n\r\n      if (callbacks) {\r\n        typeof callbacks === 'function' ? this[kCallbacks] = [callbacks, resolver] : callbacks.push(resolver);\r\n      } else {\r\n        this[kCallbacks] = resolver;\r\n      }\r\n    });\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this.then(null, onRejected);\r\n  }\r\n\r\n/*  finally(onFinally) {\r\n    const {constructor} = this;\r\n\r\n    const fn = (cb, value, isRejected, scope) => constructor.resolve(() => onFinally({value, isRejected}, scope)).then(cb);\r\n\r\n    return this.then(\r\n      (value, scope) => fn(() => value, value, false, scope),\r\n      (reason, scope) => fn(() => {throw reason}, reason, true, scope)\r\n    )\r\n  }*/\r\n\r\n  finally(callback) {\r\n    let {constructor} = this;\r\n\r\n    if ( isFunction(callback) ) {\r\n      return this.then(\r\n        (value, scope) => constructor.resolve(callback({value, status: 'fulfilled'}, scope)).then(() => value),\r\n        (reason, scope) => constructor.resolve(callback({reason, status: 'rejected'}, scope)).then(() => { throw reason; }));\r\n    }\r\n\r\n    return this.then(callback, callback);\r\n  }\r\n\r\n  static allSettled(promises) {\r\n    return this.all(Array.from(promises).map(promise => promise.then(value => ({\r\n        status: 'fulfilled', value\r\n      }), (reason) => ({\r\n        status: 'rejected', reason\r\n      }))\r\n    ))\r\n  }\r\n\r\n  get [Symbol.toStringTag](){\r\n    return 'AxiosPromise';\r\n  }\r\n\r\n  toString() {\r\n    const tag = this[kTag];\r\n    return `${this[Symbol.toStringTag]}${tag ? '#' + tag : ''}{${['pending', 'fulfilled', 'rejected'][this[kState]]}}`\r\n  }\r\n\r\n  static resolve(value, options) {\r\n    const atomic = options != null && options.atomic || 0;\r\n\r\n    if (value instanceof this && value[kSync] === this[kSync] && value[kAtomic] === atomic) {\r\n      return value;\r\n    }\r\n    const promise = new this(resolve => resolve(value));\r\n\r\n    atomic && (promise[kAtomic] = atomic);\r\n\r\n    return promise;\r\n  }\r\n\r\n  static reject(reason) {\r\n    return new this((_, reject) => reject(reason));\r\n  }\r\n\r\n  static all(promises) {\r\n    return new this((resolve, reject, {onCancel}) => {\r\n      const {length} = promises = Array.from(promises);\r\n\r\n      if (!length) {\r\n        resolve([]);\r\n        return;\r\n      }\r\n\r\n      const chains = new Array(length);\r\n      const results = new Array(length);\r\n      let cancelRequested;\r\n      let subscribed;\r\n      let canceled;\r\n      let counter = 0;\r\n\r\n      const cancel = (reason) => {\r\n        if (subscribed) {\r\n          canceled = true;\r\n          for (let i = 0; i < length; i++) {\r\n            chains[i].cancel(reason)\r\n          }\r\n        } else {\r\n          cancelRequested = true;\r\n        }\r\n      }\r\n\r\n      const _reject = (reason) => {\r\n        reject(reason);\r\n        !canceled && cancel();\r\n      };\r\n\r\n      for (let i = 0; i < length; i++) {\r\n        chains[i] = this.resolve(promises[i]).then((value) => {\r\n          results[i] = value;\r\n          if (++counter === length) {\r\n            resolve(value);\r\n          }\r\n        }, _reject);\r\n      }\r\n\r\n      subscribed = true;\r\n\r\n      cancelRequested ? cancel() : onCancel(cancel);\r\n    })\r\n  }\r\n\r\n  static race(promises) {\r\n    return new this((resolve, reject, {onCancel}) => {\r\n      const {length} = promises = Array.from(promises);\r\n\r\n      if (!length) {\r\n        return;\r\n      }\r\n\r\n      const chains = new Array(length);\r\n      let cancelRequested;\r\n      let subscribed;\r\n      let canceled;\r\n\r\n      const cancel = (reason) => {\r\n        if (subscribed) {\r\n          canceled = true;\r\n          for (let i = 0; i < length; i++) {\r\n            chains[i].cancel(reason)\r\n          }\r\n        } else {\r\n          cancelRequested = true;\r\n        }\r\n      }\r\n\r\n      const _reject = (reason) => {\r\n        try {\r\n          reject(reason);\r\n        } finally {\r\n          !canceled && cancel();\r\n        }\r\n      };\r\n\r\n      for (let i = 0; i < length; i++) {\r\n        chains[i] = this.resolve(promises[i]).then((value) => {\r\n          resolve(value);\r\n          !canceled && cancel();\r\n        }, _reject);\r\n      }\r\n\r\n      subscribed = true;\r\n\r\n      cancelRequested ? cancel() : onCancel(cancel);\r\n    })\r\n  }\r\n\r\n  static delay(ms, value) {\r\n    return new this((resolve, _, {onCancel})=> {\r\n      const timer = setTimeout(resolve, ms, value);\r\n      onCancel(()=> clearTimeout(timer));\r\n    });\r\n  }\r\n\r\n  static isCanceledError(thing) {\r\n    return CanceledError.isCanceledError(thing);\r\n  }\r\n\r\n  static isAxiosPromise(thing) {\r\n    return !!(thing && thing[kPromiseSign]);\r\n  }\r\n\r\n  static [kResolveGenerator](generator, promise) {\r\n    const onFulfilled = (result) => {\r\n      try {\r\n        next(generator.next(result));\r\n      } catch (e) {\r\n        promise[kResolveTo](e, true)\r\n      }\r\n    }\r\n\r\n    const onRejected = (err) => {\r\n      try {\r\n        next(generator.throw(err));\r\n      } catch (e) {\r\n        promise[kResolveTo](e, true);\r\n      }\r\n    }\r\n\r\n    const next = (r) => {\r\n      if (r.done) {\r\n        return promise[kResolve](r.value);\r\n      }\r\n\r\n      const innerPromise = this.resolve(r.value).then(onFulfilled, onRejected);\r\n\r\n      promise[kInnerThenable] = innerPromise;\r\n\r\n      return innerPromise;\r\n    }\r\n\r\n    onFulfilled();\r\n\r\n    return promise;\r\n  }\r\n\r\n  static [kUnhandledRejection](reason) {\r\n    const source = this[kTag] ? ` @ ${this[kTag]}` : '';\r\n    console.warn(`Unhandled AxiosPromise Rejection${source}:`, reason);\r\n  }\r\n\r\n  static promisify(fn, {scopeArg = false} = {}) {\r\n    if (!isGeneratorFunction(fn)) {\r\n      throw new TypeError(`value must be a generator function`);\r\n    }\r\n\r\n    const context = this;\r\n\r\n    return function () {\r\n      return new context((resolve, reject, scope) => {\r\n        let generatorArgs;\r\n        if (scopeArg) {\r\n          generatorArgs = [scope];\r\n          push.apply(generatorArgs, arguments);\r\n        } else {\r\n          generatorArgs = arguments;\r\n        }\r\n\r\n        context[kResolveGenerator](fn.apply(this, generatorArgs), scope)\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nconst {prototype} = AxiosPromise;\r\n\r\nprototype[kSync] = false;\r\n\r\nlazyBind(prototype, ['cancel', 'onCancel', 'signal']);\r\nlazyBind(AxiosPromise,['delay', 'promisify']);\r\n\r\nexport class AxiosPromiseSync extends AxiosPromise {\r\n  get [Symbol.toStringTag](){\r\n    return 'AxiosPromiseSync';\r\n  }\r\n}\r\n\r\nAxiosPromiseSync.prototype[kSync] = true;\r\n\r\ndefineConstants(prototype, {\r\n  CanceledError,\r\n  TimeoutError\r\n});\r\n\r\ndefineConstants(AxiosPromise, {\r\n  ATOMIC_MODE_DETACHED,\r\n  ATOMIC_MODE_AWAIT,\r\n  ATOMIC_MODE_DISABLED\r\n})\r\n\r\nexport {\r\n  utils,\r\n  AbortSignal,\r\n  AbortController,\r\n  EventEmitter,\r\n};\r\n"],"names":["hasOwn","hasOwnProperty","obj","prop","call","Object","prototype","isFunction","thing","_global","globalThis","global","self","window","_setImmediate","setImmediateSupported","setImmediate","postMessageSupported","postMessage","token","Math","random","callbacks","addEventListener","source","data","length","shift","cb","push","setTimeout","asap","queueMicrotask","process","nextTick","functionTypeTest","constructor","isGeneratorFunction","isAsyncFunction","async","isPlainFunction","isContextDefined","context","isAbortSignal","aborted","removeEventListener","utils","lazyBind","props","bindMethods","symbols","forEach","symbol","Symbol","descriptor","getOwnPropertyDescriptor","value","get","enumerable","defineProperty","this","resolvedValue","boundContext","apply","arguments","set","v","Error","configurable","console","warn","isGenerator","next","throw","defineConstants","descriptors","getOwnPropertyNames","defineProperties","isAbortController","abort","signal","tags","iterator","kInternals","kSignature","for","CanceledError","message","super","name","code","static","isCanceledError","err","toUpperCase","replace","addSignature","init","TimeoutError","messageOrTimeout","EventEmitter","events","_events","on","event","listener","prepend","listeners","emit","unshift","off","found","i","splice","args","Array","from","slice","l","once","listenerCount","kSignal","kAborted","kAbort","kEvents","hasNativeSupport","AbortController","AbortSignal","_AbortSignal","dispatchEvent","type","target","toStringTag","toString","_AbortController","reason","kPromiseSign","kState","kValue","kCallbacks","kDoResolve","kResolveTo","kResolve","kParent","kInnerThenable","kCanceled","kFinalized","kSync","kCallback","kCancelCallbacks","kFinalize","kUnsubscribe","kResolveGenerator","kAtomic","kCanceledWith","kUncaught","kTag","kUnhandledRejection","kTimer","hasConsole","noop","invokeCallbacks","that","AxiosPromise","executor","timeout","signals","cancel","listen","TypeError","fn","fnContext","done","e","ms","clearTimeout","tag","String","atomic","mode","promise","then","chain","resolve","uncaught","handler","appendedHandler","forced","parent","innerThenable","scope","internals","onCancel","controller","parentCallbacks","callback","isRejected","canceled","cancelCallbacks","hasCallback","uncaughtCallbacks","settled","getMethod","onFulfilled","onRejected","$","$$","invoked","resolver","catch","finally","status","promises","all","map","options","_","reject","chains","results","cancelRequested","subscribed","counter","_reject","timer","generator","result","r","innerPromise","scopeArg","generatorArgs","AxiosPromiseSync","ATOMIC_MODE_DETACHED","ATOMIC_MODE_AWAIT","ATOMIC_MODE_DISABLED"],"mappings":"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"}